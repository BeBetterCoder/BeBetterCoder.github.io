{"meta":{"title":"ZimaBlue's Blog","subtitle":"Some thoughts","description":"","author":"ZimaBlue","url":"http://example.com","root":"/"},"pages":[{"title":"文章分类","date":"2019-07-29T02:13:21.000Z","updated":"2021-11-21T10:49:36.627Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"对称密码","slug":"对称密码","date":"2022-03-23T05:33:14.000Z","updated":"2022-03-23T06:01:26.774Z","comments":true,"path":"2022/03/23/对称密码/","link":"","permalink":"http://example.com/2022/03/23/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/","excerpt":"​ OFPPT-CTF的一道题，AES的中间相遇攻击，实际上也是任何对称密码加密两次的攻击方法。攻击思路就是把给的密文解密一次，已知的明文（或者遍历明文的所有组合）加密一次，来对照两者的结果，若相等则可以确定加解密的密钥。","text":"​ OFPPT-CTF的一道题，AES的中间相遇攻击，实际上也是任何对称密码加密两次的攻击方法。攻击思路就是把给的密文解密一次，已知的明文（或者遍历明文的所有组合）加密一次，来对照两者的结果，若相等则可以确定加解密的密钥。 Q： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from random import randintfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padimport jsonflag = b&#x27;OFPPT-CTF&#123;Not_the_real_flag&#125;&#x27;def gen_key(option=0): alphabet = b&#x27;0123456789abcdef&#x27; const = b&#x27;0fpptCTF5!@#&#x27; key = b&#x27;&#x27; for i in range(16-len(const)): key += bytes([alphabet[randint(0,15)]]) if option: return key + const else: return const + keydef encrypt(data, key1, key2): cipher = AES.new(key1, mode=AES.MODE_ECB) ct = cipher.encrypt(pad(data, 16)) cipher = AES.new(key2, mode=AES.MODE_ECB) ct = cipher.encrypt(ct) return ct.hex()def challenge(): k1 = gen_key() k2 = gen_key(1) ct = encrypt(flag, k1, k2) print(&#x27;Super strong encryption service approved by 2022 stansdards.\\n&#x27;+\\ &#x27;Message to decrypt:\\n&#x27; +ct + &#x27;\\nEncrypt your text:\\n&gt; &#x27;) try: dt = json.loads(input().strip()) pt = bytes.fromhex(dt[&#x27;pt&#x27;]) res = encrypt(pt, k1, k2) print(res + &#x27;\\n&#x27;) exit(1) except Exception as e: print(e) print(&#x27;Invalid payload.\\n&#x27;) exit(1) if __name__ == &quot;__main__&quot;: challenge() DATA: 1234567Super strong encryption service approved by 2022 stansdards.Message to decrypt:187f25ea856f518bcd8e7e7c17e7e6016bc77459513740e6792c84d07b465ea9cee6609881421eb4ae1606792a2d8859Encrypt your text:&gt;&#123;&quot;pt&quot;:&quot;4f465050542d435446&quot;&#125;f71f3b195e2336a6d30077b8184304c6 ​ 这道题给了一对明文——密文对，那么可以通过遍历密钥空间来分别对明文加密一次，密文解密一次。只要取两者交集就能得到密钥。 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from Crypto.Cipher import AESfrom Crypto.Util.Padding import padpt=&#x27;4f465050542d435446&#x27;pt = bytes.fromhex(pt)c=&#x27;f71f3b195e2336a6d30077b8184304c6&#x27;c=bytes.fromhex(c)alphabet = b&#x27;0123456789abcdef&#x27;const = b&#x27;0fpptCTF5!@#&#x27;dict=&#123;&#125;def check(a): if a in dict.keys(): print(dict[a]) return 1 else: return 0for i1 in range(16): for i2 in range(16): for i3 in range(16): for i4 in range(16): key1=const+bytes([alphabet[i1]])+bytes([alphabet[i2]])+bytes([alphabet[i3]])+bytes([alphabet[i4]]) cipher = AES.new(key1, mode=AES.MODE_ECB) ct = cipher.encrypt(pad(pt, 16)) index1=str(i1)+&#x27; &#x27;+str(i2)+&#x27; &#x27;+str(i3)+&#x27; &#x27;+str(i4) dict[ct]=index1for i1 in range(16): for i2 in range(16): for i3 in range(16): for i4 in range(16): key2=bytes([alphabet[i1]])+bytes([alphabet[i2]])+bytes([alphabet[i3]])+bytes([alphabet[i4]])+const cipher = AES.new(key2, mode=AES.MODE_ECB) ct = cipher.decrypt(c) index2=str(i1)+&#x27; &#x27;+str(i2)+&#x27; &#x27;+str(i3)+&#x27; &#x27;+str(i4) if check(ct): print(index2)c=&#x27;187f25ea856f518bcd8e7e7c17e7e6016bc77459513740e6792c84d07b465ea9cee6609881421eb4ae1606792a2d8859&#x27;c=bytes.fromhex(c)index1=[2,15,7,4]index2=[14,10,1,4]key1=constkey2=b&#x27;&#x27;for i in range(4): key1+=bytes([alphabet[index1[i]]]) key2+=bytes([alphabet[index2[i]]])key2+=constcipher1 = AES.new(key1, mode=AES.MODE_ECB)cipher2 = AES.new(key2, mode=AES.MODE_ECB)m=cipher2.decrypt(c)print(cipher1.decrypt(m))#b&#x27;OFPPT-CTF&#123;M33t_1n_Th3_Middle_4tt4ck_4_RS4&#125;\\x06\\x06\\x06\\x06\\x06\\x06&#x27; ​ 第二种思路应该算是非预期，因为直到flag格式为：OFPPT-CTF{，那么可以考虑爆破后续的6字节，再将这16字节进行遍历密钥的加密；同时对密文进行遍历密钥的解密，对照前16字节，若两者前16字节相等则两者取得密钥就是先后加密两次的密钥。但是时间复杂度较高，不是好的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom binascii import b2a_hex, a2b_heximport string# def decrypt(key,c):# cipher = AES.new(key, mode=AES.MODE_ECB)# ct = cipher.decrypt(c)# return ct## c = &#x27;187f25ea856f518bcd8e7e7c17e7e6016bc77459513740e6792c84d07b465ea9cee6609881421eb4ae1606792a2d8859&#x27;# const = &#x27;0fpptCTF5!@#&#x27;# alphabet = &#x27;0123456789abcdef&#x27;# f = open(&quot;msg.txt&quot;,&quot;w&quot;)# for i in range(16):# for j in range(16):# for m in range(16):# for n in range(16):# key2 = bytes( alphabet[i] + alphabet[j] + alphabet[m] + alphabet[n] + const,encoding=&quot;utf-8&quot;)# flag = decrypt(key2,a2b_hex(c))# f.write(str(flag))# f.write(&quot;\\n&quot;)# 不同密钥解密出的所有可能结果存在msg.txt中def encrypt(key,m): cipher = AES.new(key, mode=AES.MODE_ECB) ct = cipher.encrypt(m) return ctknown = &#x27;OFPPT-CTF&#123;&#x27;const = &#x27;0fpptCTF5!@#&#x27;table = &#x27;0123456789abcdef&#x27;ff = open(&quot;c1.txt&quot;,&quot;w&quot;)for i1 in range(16): for i2 in range(16): for i3 in range(16): for i4 in range(16): for i5 in range(16): for i6 in range(16): mm = bytes(known+table[i1]+table[i2]+table[i3]+table[i4]+table[i5]+table[i6],encoding=&#x27;utf-8&#x27;) for i in range(16): for j in range(16): for m in range(16): for n in range(16): key1 = bytes(const + table[i] + table[j] + table[m] + table[n], encoding=&quot;utf-8&quot;) c1 = encrypt(key1,mm) ff.write(str(c1)) # 爆破未知6字节，遍历密钥空间，获得所有可能的加密结果；最后只需要对照msg.txt和c1.txt，找到前十六个字节相同的那两组。","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"对称密码","slug":"比赛/对称密码","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/"},{"name":"中间相遇攻击","slug":"比赛/对称密码/中间相遇攻击","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/%E4%B8%AD%E9%97%B4%E7%9B%B8%E9%81%87%E6%94%BB%E5%87%BB/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"AES","slug":"AES","permalink":"http://example.com/tags/AES/"},{"name":"中间相遇攻击","slug":"中间相遇攻击","permalink":"http://example.com/tags/%E4%B8%AD%E9%97%B4%E7%9B%B8%E9%81%87%E6%94%BB%E5%87%BB/"}]},{"title":"2022红明谷-easy_ya","slug":"2022红明谷-easy-ya","date":"2022-03-22T10:49:30.000Z","updated":"2022-03-22T11:10:42.911Z","comments":true,"path":"2022/03/22/2022红明谷-easy-ya/","link":"","permalink":"http://example.com/2022/03/22/2022%E7%BA%A2%E6%98%8E%E8%B0%B7-easy-ya/","excerpt":"​ 红明谷一共就八个题，和小老弟组队，做了四个题 RANK50。密码学有两道，一题是copper，另一题是sm2，不会做。这里简单记录一下第一题。","text":"​ 红明谷一共就八个题，和小老弟组队，做了四个题 RANK50。密码学有两道，一题是copper，另一题是sm2，不会做。这里简单记录一下第一题。 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *import osfrom flag import flagdef gen(): e = 3 while True: try: p = getPrime(512) q = getPrime(512) n = p*q phi = (p-1)*(q-1) d = inverse(e,phi) return p,q,d,n,e except: continue returnp,q,d,n,e = gen()r = getPrime(512)m = bytes_to_long(flag+os.urandom(32))M = m%rc = pow(m,e,n)print(&quot;r = %d&quot;%r)print(&quot;M = %d&quot;%M)print(&quot;n = %d&quot;%n)print(&quot;e = %d&quot;%e)print(&quot;c = %d&quot;%c)&#x27;&#x27;&#x27;r = 7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473M = 4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558n = 131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287e = 3c = 46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282&#x27;&#x27;&#x27; ​ 根据已知关系推导： c = (r*x+M)^3modn m = M+r*x​ 那么就转化为求下面这个多项式的根： ((r*x+M)^3 - c) modn = 0​ sage脚本： 12345678910111213N = 131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287e = 3c = 46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282M = 4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558r = 7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473kbits = 100ZmodN = Zmod(N)P.&lt;x&gt; = PolynomialRing(ZmodN)f = (M + r*x)^e - cf=f.monic()x0 = f.small_roots(x=2^kbits, beta=1)[0] # 这里的X选取不像上文用的是临界值，而是选了一个我们未知的x的最大可能值。X的选取并非严格，但至少得保证比临界值小。print(x0)#810968823598060539864535 ​ 利用x0还原m就解出来了。","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"RSA","slug":"比赛/RSA","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/"},{"name":"Copper","slug":"比赛/RSA/Copper","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/Copper/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"Copper","slug":"Copper","permalink":"http://example.com/tags/Copper/"}]},{"title":"pollard's p-1","slug":"pollard-s-p-1","date":"2022-03-17T14:28:17.000Z","updated":"2022-03-18T02:24:24.069Z","comments":true,"path":"2022/03/17/pollard-s-p-1/","link":"","permalink":"http://example.com/2022/03/17/pollard-s-p-1/","excerpt":"​ 当p-1为smooth number（指可以分解为小素数乘积的正整数）时，可以用pollard’s p-1算法来分解公钥n，详情见https://blog.csdn.net/zippo1234/article/details/109811874","text":"​ 当p-1为smooth number（指可以分解为小素数乘积的正整数）时，可以用pollard’s p-1算法来分解公钥n，详情见https://blog.csdn.net/zippo1234/article/details/109811874 例题就是picoCTF的一道题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#!/usr/bin/pythonfrom binascii import hexlifyfrom gmpy2 import *import mathimport osimport sysif sys.version_info &lt; (3, 9): math.gcd = gcd math.lcm = lcm_DEBUG = FalseFLAG = open(&#x27;flag.txt&#x27;).read().strip()FLAG = mpz(hexlify(FLAG.encode()), 16)SEED = mpz(hexlify(os.urandom(32)).decode(), 16)STATE = random_state(SEED)def get_prime(state, bits): return next_prime(mpz_urandomb(state, bits) | (1 &lt;&lt; (bits - 1)))def get_smooth_prime(state, bits, smoothness=16): p = mpz(2) p_factors = [p] while p.bit_length() &lt; bits - 2 * smoothness: factor = get_prime(state, smoothness) p_factors.append(factor) p *= factor bitcnt = (bits - p.bit_length()) // 2 while True: prime1 = get_prime(state, bitcnt) prime2 = get_prime(state, bitcnt) tmpp = p * prime1 * prime2 if tmpp.bit_length() &lt; bits: bitcnt += 1 continue if tmpp.bit_length() &gt; bits: bitcnt -= 1 continue if is_prime(tmpp + 1): p_factors.append(prime1) p_factors.append(prime2) p = tmpp + 1 break p_factors.sort() return (p, p_factors)e = 0x10001while True: p, p_factors = get_smooth_prime(STATE, 1024, 16) if len(p_factors) != len(set(p_factors)): continue # Smoothness should be different or some might encounter issues. q, q_factors = get_smooth_prime(STATE, 1024, 17) if len(q_factors) != len(set(q_factors)): continue factors = p_factors + q_factors if e not in factors: breakif _DEBUG: import sys sys.stderr.write(f&#x27;p = &#123;p.digits(16)&#125;\\n\\n&#x27;) sys.stderr.write(f&#x27;p_factors = [\\n&#x27;) for factor in p_factors: sys.stderr.write(f&#x27; &#123;factor.digits(16)&#125;,\\n&#x27;) sys.stderr.write(f&#x27;]\\n\\n&#x27;) sys.stderr.write(f&#x27;q = &#123;q.digits(16)&#125;\\n\\n&#x27;) sys.stderr.write(f&#x27;q_factors = [\\n&#x27;) for factor in q_factors: sys.stderr.write(f&#x27; &#123;factor.digits(16)&#125;,\\n&#x27;) sys.stderr.write(f&#x27;]\\n\\n&#x27;)n = p * qm = math.lcm(p - 1, q - 1)d = pow(e, -1, m)c = pow(FLAG, e, n)print(f&#x27;n = &#123;n.digits(16)&#125;&#x27;)print(f&#x27;c = &#123;c.digits(16)&#125;&#x27;)#n = 65446ab139efe9744c78a271ad04d94ce541a299f9d4dcb658f66f49414fb913d8ac6c90dacc1ad43135454c3c5ac76c56d71d2816dac23db5c8caa773ae2397bd5909a1f2823c230f44ac684c437f16e4ca75d50b75d2f7e5549c034aa8a723c9eaa904572a8c5c6c1ed7093a0695522a5c41575c4dbf1158ca940c02b223f50ae86e6782819278d989200a2cd2be4b7b303dffd07209752ee5a3060c6d910a108444c7a769d003bf8976617b4459fdc15a2a73fc661564267f55be6a0d0d2ec4c06a4951df5a096b079d9e300f7ad72fa6c73a630f9a38e472563434c10225bde7d08c651bdd23fd471077d44c6aab4e01323ed78641983b29633ad104f3fd#c = 19a98df2bfd703a31fedff8a02d43bc11f1fb3c15cfa7a55b6a32b3532e1ac477f6accc448f9b7d2b4deaae887450217bb70298afaa0f5e31a77e7c6f8ba1986979f15d299230119e3dd7e42eb9ca4d58d084d18b328fbe08c8909a2afc67866d6550e4e6fa27dc13d05c51cc87259fe73e2a1890cc2825d76c8b2a99f72f6023fc96658ac355487a6c275717ca6c13551094818efae1cec3c8773cc5a72fed518c00a53ba9799d9d5c182795dfcece07c727183fdd86fd2cb4b95e9f231be1858320aa7f8430885eb3d24300552d1a83158636316e55e6ac0a30a608964dbf2c412aed6a15df5fd49e737f7c06c02360d0c292abc33a3735152db2fb5bc5f6d 只是看起来复杂罢了，利用p-1光滑就能快速分解n了。 123456789101112131415161718192021222324252627from Crypto.Util.number import *from gmpy2 import *def Pollards_p_1(N): a = 2 n = 2 while True: a = pow(a, n, N) res = gcd(a-1, N) if res != 1 and res != N: print (&#x27;n =&#x27;, n) print (&#x27;p =&#x27;, res) return res n += 1 N = 0x65446ab139efe9744c78a271ad04d94ce541a299f9d4dcb658f66f49414fb913d8ac6c90dacc1ad43135454c3c5ac76c56d71d2816dac23db5c8caa773ae2397bd5909a1f2823c230f44ac684c437f16e4ca75d50b75d2f7e5549c034aa8a723c9eaa904572a8c5c6c1ed7093a0695522a5c41575c4dbf1158ca940c02b223f50ae86e6782819278d989200a2cd2be4b7b303dffd07209752ee5a3060c6d910a108444c7a769d003bf8976617b4459fdc15a2a73fc661564267f55be6a0d0d2ec4c06a4951df5a096b079d9e300f7ad72fa6c73a630f9a38e472563434c10225bde7d08c651bdd23fd471077d44c6aab4e01323ed78641983b29633ad104f3fdPollards_p_1(N)e = 0x10001p = 99126027751293787460707333225370081580584982304038231096813161244761524095590615117831448502823590451345284755118126397029033735152688999710147646678545625634287769168400222908200102457283937611678386858046723404913983230996949238395868265074908432952904759110064966754913625273131550827408850464386561335667q = 128965183581768163664978030498027146361112997382480284467816270831653077525969847879430397647540675619100157280183116707523593845084067419846780398725528236058905044567351849099700699570794288281913389080617917506884306793829926019232415711115188439634653794440433245851643026110952784986360042886715063777487c = 0x19a98df2bfd703a31fedff8a02d43bc11f1fb3c15cfa7a55b6a32b3532e1ac477f6accc448f9b7d2b4deaae887450217bb70298afaa0f5e31a77e7c6f8ba1986979f15d299230119e3dd7e42eb9ca4d58d084d18b328fbe08c8909a2afc67866d6550e4e6fa27dc13d05c51cc87259fe73e2a1890cc2825d76c8b2a99f72f6023fc96658ac355487a6c275717ca6c13551094818efae1cec3c8773cc5a72fed518c00a53ba9799d9d5c182795dfcece07c727183fdd86fd2cb4b95e9f231be1858320aa7f8430885eb3d24300552d1a83158636316e55e6ac0a30a608964dbf2c412aed6a15df5fd49e737f7c06c02360d0c292abc33a3735152db2fb5bc5f6dphi = (p-1)*(q-1)d = invert(e,phi)print(long_to_bytes(pow(c,d,N)))#picoCTF&#123;376ebfe7&#125;","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"RSA","slug":"比赛/RSA","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/"},{"name":"pollard's p-1","slug":"比赛/RSA/pollard-s-p-1","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/pollard-s-p-1/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"光滑数攻击","slug":"光滑数攻击","permalink":"http://example.com/tags/%E5%85%89%E6%BB%91%E6%95%B0%E6%94%BB%E5%87%BB/"}]},{"title":"Paillier加密方案","slug":"Paillier加密方案","date":"2022-03-11T07:32:27.000Z","updated":"2022-03-17T15:20:55.188Z","comments":true,"path":"2022/03/11/Paillier加密方案/","link":"","permalink":"http://example.com/2022/03/11/Paillier%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88/","excerpt":"​ 懒得码字，直接搬运大佬博客。","text":"​ 懒得码字，直接搬运大佬博客。 ​ 首先是卡迈克尔函数：https://baike.baidu.com/item/%E5%8D%A1%E8%BF%88%E5%85%8B%E5%B0%94%E5%87%BD%E6%95%B0/22786506?fr=aladdin ​ 然后是两个写的比较好的博客：https://www.cnblogs.com/TheFutureIsNow/p/12099608.html ​ https://blog.csdn.net/sinianluoye/article/details/82855059 ​ 重点部分： ​ 通常题目都是这样来选取密钥的：","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"同态加密","slug":"比赛/同态加密","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"},{"name":"Paillier","slug":"比赛/同态加密/Paillier","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/Paillier/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"同态加密","slug":"同态加密","permalink":"http://example.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"}]},{"title":"长亭-PWNHUB系列","slug":"长亭-PWNHUB系列","date":"2022-03-10T15:12:43.000Z","updated":"2022-03-15T02:29:48.579Z","comments":true,"path":"2022/03/10/长亭-PWNHUB系列/","link":"","permalink":"http://example.com/2022/03/10/%E9%95%BF%E4%BA%AD-PWNHUB%E7%B3%BB%E5%88%97/","excerpt":"sign_in_rsa​ 给了五个friends的公钥，其中N都一样，e1-e5不同，推导有： 1flag^(e1*e2*e3*e4*e5) mod N = c","text":"sign_in_rsa​ 给了五个friends的公钥，其中N都一样，e1-e5不同，推导有： 1flag^(e1*e2*e3*e4*e5) mod N = c ​ 由于还给了一组N,e,d，所以可以通过ed-1 // N 计算出k，而k+1 通常就是ed-1//phi,那么可以求出phi，最后只需要求出e1-e5的乘积对于phi的逆就可解密。 123456789101112131415161718from Crypto.Util.number import *import gmpy2c = 2621668640772056420471560098924704127784856790481388457844412769822118088860174800889321751481674422274270598394172919656578632970378187564960846030071830293875552723490431731972841568891484366856527528595054839456764493791012121047269761236912586905892771816051261702781783915560998982829509529868080760864895962974173385898354122495270178096361803788632815673814331531474332060419597040425174040815031894440262657639509623993308964349172916870911290368660953787873798343194799625182081014696063160131605363197089825537641567810410348240587342655465209891653946637101421879415183319402455214734741851508514452049810e = 0x10001n = 15029760235374231085969639414731714595094502023579580515142415364576906256445975070594748351717296265506796113025536826427911733196972964855469386448087417878697745924349624863909303165292167253527223263941652633363973854290523602860560486258509324353520104509387932968280508674316342236523385959602558170958614970693493378178016898028008319433088550790771390116863660130486812753414200478905354927474330477084174838392457570478397763649784441576899752400739324537777431123697771882670997321209911034933464741353255233083149611904906129535499692359926063803373853328404277847957250932127456840832115242266989310408337d = 6510060024132448812692374598562478938781873276826121917136087171433612126001066486549172550775880633671688073309060742661536694848138785012316851139079566219427085669995770343650050947604387625705743119055063449704794632066543990637391557798194976737161835401498317792553501071727695913273255675957670000137254200491232988916899437811704442351184491702933366588255664254218916419493613957433723990485119540500734398920034539046985131363424063852960232153505171116298416691316690158260663800875225380729824947022224315510290836013992740531252154869626076244458736535349817731705617890688617614422279803126347527748253k = (e*d - 1)//nprint(k)phi = (e*d - 1)//(k+1)l = [(15029760235374231085969639414731714595094502023579580515142415364576906256445975070594748351717296265506796113025536826427911733196972964855469386448087417878697745924349624863909303165292167253527223263941652633363973854290523602860560486258509324353520104509387932968280508674316342236523385959602558170958614970693493378178016898028008319433088550790771390116863660130486812753414200478905354927474330477084174838392457570478397763649784441576899752400739324537777431123697771882670997321209911034933464741353255233083149611904906129535499692359926063803373853328404277847957250932127456840832115242266989310408337, 107273), (15029760235374231085969639414731714595094502023579580515142415364576906256445975070594748351717296265506796113025536826427911733196972964855469386448087417878697745924349624863909303165292167253527223263941652633363973854290523602860560486258509324353520104509387932968280508674316342236523385959602558170958614970693493378178016898028008319433088550790771390116863660130486812753414200478905354927474330477084174838392457570478397763649784441576899752400739324537777431123697771882670997321209911034933464741353255233083149611904906129535499692359926063803373853328404277847957250932127456840832115242266989310408337, 80021), (15029760235374231085969639414731714595094502023579580515142415364576906256445975070594748351717296265506796113025536826427911733196972964855469386448087417878697745924349624863909303165292167253527223263941652633363973854290523602860560486258509324353520104509387932968280508674316342236523385959602558170958614970693493378178016898028008319433088550790771390116863660130486812753414200478905354927474330477084174838392457570478397763649784441576899752400739324537777431123697771882670997321209911034933464741353255233083149611904906129535499692359926063803373853328404277847957250932127456840832115242266989310408337, 110281), (15029760235374231085969639414731714595094502023579580515142415364576906256445975070594748351717296265506796113025536826427911733196972964855469386448087417878697745924349624863909303165292167253527223263941652633363973854290523602860560486258509324353520104509387932968280508674316342236523385959602558170958614970693493378178016898028008319433088550790771390116863660130486812753414200478905354927474330477084174838392457570478397763649784441576899752400739324537777431123697771882670997321209911034933464741353255233083149611904906129535499692359926063803373853328404277847957250932127456840832115242266989310408337, 125399), (15029760235374231085969639414731714595094502023579580515142415364576906256445975070594748351717296265506796113025536826427911733196972964855469386448087417878697745924349624863909303165292167253527223263941652633363973854290523602860560486258509324353520104509387932968280508674316342236523385959602558170958614970693493378178016898028008319433088550790771390116863660130486812753414200478905354927474330477084174838392457570478397763649784441576899752400739324537777431123697771882670997321209911034933464741353255233083149611904906129535499692359926063803373853328404277847957250932127456840832115242266989310408337, 77641)]e_ = 1for i in l: e_ = e_* i[1]print(e_)d_ = gmpy2.invert(e_,phi)print(long_to_bytes(pow(c,d_,n)))#flag&#123;3ncrypt_y0ur_s3cr3t_w1th_y0ur_fr1end5_publ1c_k3y&#125;","categories":[{"name":"PWNHUB","slug":"PWNHUB","permalink":"http://example.com/categories/PWNHUB/"},{"name":"公开赛","slug":"PWNHUB/公开赛","permalink":"http://example.com/categories/PWNHUB/%E5%85%AC%E5%BC%80%E8%B5%9B/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"pwnhub","slug":"pwnhub","permalink":"http://example.com/tags/pwnhub/"}]},{"title":"d3ctf-LFSR","slug":"d3ctf-LFSR","date":"2022-03-10T14:27:17.000Z","updated":"2022-03-10T14:38:52.103Z","comments":true,"path":"2022/03/10/d3ctf-LFSR/","link":"","permalink":"http://example.com/2022/03/10/d3ctf-LFSR/","excerpt":"​ 由于异或的可逆性和相消性，推到可以得到message的前34位就是myResult的1-35位，而剩余30位未知，就可以利用矩阵方程组来解。","text":"​ 由于异或的可逆性和相消性，推到可以得到message的前34位就是myResult的1-35位，而剩余30位未知，就可以利用矩阵方程组来解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from Crypto.Util.number import *from sage.all import *from functools import reducedef xor(a,b): return a^bdef right_reduce(a,b): return reduce(xor,[ a[i]&amp;b[i] for i in range(len(a))])mask = &#x27;1010010000001000000010001001010010100100000010000000100010010100&#x27;xor_output = &#x27;00100110001000110001101010101001001&#x27;and_output = &#x27;01111101111010111000010010111001101&#x27;message = &#x27;&#x27;#可以证明，message的前34位就是xor_output的1-34位for i in range(1,35): message += str(int(xor_output[i]))and_output=and_output[:-5]#矩阵方程等号左边系数矩阵r_and=[int(i) for i in and_output]r_xor=[int(i) for i in xor_output[1:35]]A = [int(i) for i in mask[34:]]AA = []for i in range(30): A = [int(i) for i in mask[(34-i):(64-i)]] AA.append(A)print(AA)AA=matrix(GF(2),AA)r = []for i in range(30): a = [r_xor[j] for j in range(i,34)] b = [int(mask[k]) for k in range(0,34-i)] if i == 0: c = [0] d = [0] else: c = [r_and[l] for l in range(0,i)] d = [int(mask[p]) for p in range(63,63-i,-1)] r.append(right_reduce(a,b) ^ right_reduce(c,d) ^ r_and[i])rr = vector(GF(2),r)print(rr)ans = AA.solve_right(rr)print(ans)ans = list(ans)low_bit = &#x27;&#x27;for i in ans: low_bit += str(i)message = message + low_bitprint(long_to_bytes(int(message,2)))#LF5Rsuk!","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"LFSR","slug":"比赛/LFSR","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/LFSR/"},{"name":"矩阵方程求解法","slug":"比赛/LFSR/矩阵方程求解法","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/LFSR/%E7%9F%A9%E9%98%B5%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3%E6%B3%95/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"LFSR","slug":"LFSR","permalink":"http://example.com/tags/LFSR/"}]},{"title":"小指数加密","slug":"小指数加密","date":"2022-03-05T02:57:07.000Z","updated":"2022-03-15T02:31:27.625Z","comments":true,"path":"2022/03/05/小指数加密/","link":"","permalink":"http://example.com/2022/03/05/%E5%B0%8F%E6%8C%87%E6%95%B0%E5%8A%A0%E5%AF%86/","excerpt":"​ 在RSA加密的过程中，如果e选的过小，比如3、5等，则m^e可能小于n，即m^e modn = m^e，那么就可以通过直接对密文开e次方求出明文，这就是小指数加密的缺陷。 ​ 通常在ctf题目中，还会遇到小指数加密广播攻击，即同一个消息用同一个小指数e和不同的n进行加密，那么就可以利用n，c的关系建立同余方程组，然后用中国剩余定理解出明文的e次方，最后仅需要开方就可获得明文。","text":"​ 在RSA加密的过程中，如果e选的过小，比如3、5等，则m^e可能小于n，即m^e modn = m^e，那么就可以通过直接对密文开e次方求出明文，这就是小指数加密的缺陷。 ​ 通常在ctf题目中，还会遇到小指数加密广播攻击，即同一个消息用同一个小指数e和不同的n进行加密，那么就可以利用n，c的关系建立同余方程组，然后用中国剩余定理解出明文的e次方，最后仅需要开方就可获得明文。 ​ 举个例子： 12345678N = 331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004 c = 310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243N = 302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114 c = 112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344N = 332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323 c = 10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242 ​ 这就是典型的广播攻击，脚本： 1234567891011121314151617181920212223242526272829303132from sympy.ntheory.modular import *from Crypto.Util.number import *import gmpy2#这里给的数据是5进制，需要仔细观察每一位不大于4n1 = int(str( 331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004), 5)c1 = int(str( 310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243), 5)n2 = int(str( 302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114), 5)c2 = int(str( 112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344), 5)n3 = int(str( 332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323), 5)c3 = int(str( 10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242), 5)n = [n1, n2, n3]c = [c1, c2, c3]ans = crt(n,c)[0]ans = gmpy2.iroot(ans, 3)[0]print(long_to_bytes(ans))# noxCTF&#123;D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!&#125; ​ 关于中国剩余定理，除了直接调用库也可以自己实现，参考https://www.cnblogs.com/lingxuer/p/15018137.html","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"RSA","slug":"比赛/RSA","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/"},{"name":"小指数加密","slug":"比赛/RSA/小指数加密","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/%E5%B0%8F%E6%8C%87%E6%95%B0%E5%8A%A0%E5%AF%86/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"小指数加密","slug":"小指数加密","permalink":"http://example.com/tags/%E5%B0%8F%E6%8C%87%E6%95%B0%E5%8A%A0%E5%AF%86/"},{"name":"中国剩余定理","slug":"中国剩余定理","permalink":"http://example.com/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"}]},{"title":"秘密分割","slug":"秘密分割","date":"2022-03-05T02:17:10.000Z","updated":"2022-03-05T02:52:00.061Z","comments":true,"path":"2022/03/05/秘密分割/","link":"","permalink":"http://example.com/2022/03/05/%E7%A7%98%E5%AF%86%E5%88%86%E5%89%B2/","excerpt":"​ 秘密分割的思想是将秘密以适当的方式拆分，拆分后的每一个份额由不同的参与者管理，单个参与者无法恢复秘密信息，只有若干个参与者一同协作才能恢复秘密消息。更重要的是，当其中任何相应范围内参与者出问题时，秘密仍可以完整恢复。 ​ 秘密分割是一种将秘密分割存储的密码技术，目的是阻止秘密过于集中，以达到分散风险和容忍入侵的目的，是信息安全和数据保密中的重要手段。","text":"​ 秘密分割的思想是将秘密以适当的方式拆分，拆分后的每一个份额由不同的参与者管理，单个参与者无法恢复秘密信息，只有若干个参与者一同协作才能恢复秘密消息。更重要的是，当其中任何相应范围内参与者出问题时，秘密仍可以完整恢复。 ​ 秘密分割是一种将秘密分割存储的密码技术，目的是阻止秘密过于集中，以达到分散风险和容忍入侵的目的，是信息安全和数据保密中的重要手段。 ​ 这里先学习两种秘密分割方案，第一种是Shamir方案，其数学原理是利用抛物线上的点值和拉格朗日插值定律恢复曲线，当有足够多的点的时候，秘密就可以被恢复；Asmuth-Bloom方案则是基于中国剩余定理的门限方案。具体原理见：https://webencrypt.org/secretsharing/ 可参考论文：可验证的Asmuth-Bloom门限秘密共享方案 ​ 举一个例子来说明秘密分割的有效性： [AFCTF2018]花开藏宝地​ 题目给了五个压缩包，并提示打开三个压缩包便可解密，五个压缩包解密方法依次是：爆破数字秘密、爆破小写字母密码、爆破大写字母密码、伪加密、NTFS文件隐写，可参考https://blog.csdn.net/qq_41079177/article/details/102964134 。全部解压以后，发现是五个m1-x1对，再联想到花开（bloom），猜测是密码分割方案，于是只需要按照原理用一次中国剩余定理，再减去AP（或者模p）即可恢复原文。 12345678910111213141516171819202122from Crypto.Util.number import *import gmpy2from sympy.ntheory.modular import crtx1 = 305345133911395218573790903508296238659147802274031796643017539011648802808763162902335644195648525375518941848430114497150082025133000033835083076541927530829557051524161069423494451667848236452337271862085346869364976989047180532167560796470067549915390773271207901537847213882479997325575278672917648417868759077150999044891099206133296336190476413164240995177077671480352739572539631359m1 = 347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820813413x2 = 152012681270682340051690627924586232702552460810030322267827401771304907469802591861912921281833890613186317787813611372838066924894691892444503039545946728621696590087591246339208248647926966446848123290344911662916758039134817404720512465817867255277476717353439505243247568126193361558042940352204093381260402400739429050280526212446967632582771424597203000629197487733610187359662268583m2 = 347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820818553x3 = 40952412095267791829743119118333311932687870987919948671780408726886151430242690997238831410249436653299224291445012397813221016909468630372862610415470277301591535416193017906909638241212666990959976187895288689640250810487806568164431359887246760313154046201720715301307811951233077581047872827004824833876458687145628724339714212107812941785880896399800008924818580623979723496070665230m3 = 347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820819351x4 = 100459779913520540098065407420629954816677926423356769524759072632219106155849450125185205557491138357760494272691949199099803239098119602186117878931534968435982565071570831032814288620974807498206233914826253433847572703407678712965098320122549759579566316372220959610814573945698083909575005303253205653244238542300266460559790606278310650849881421791081944960157781855164700773081375247m4 = 347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820820091x5 = 230502064382947282343660159791611936696520807970361139469603458689311286041516767875903549263861950740778705012699983268093626403307298415066249636346303539570207577050391796770068203937723627361951969413683246596072925692670365490970847825269581004483964261491917680759091791653759514213188778401968676433284753781006738293752440186858616315727565803777032119737689210471541053061940547213m5 = 347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820822249x = [x1, x2, x3]m = [m1, m2, m3]p = 80804238007977405688648566160504278593148666302626415149704905628622876270862865768337953835725801963142685182510812938072115996355782396318303927020705623120652014080032809421180400984242061592520733710243483947230962631945045134540159517488288781666622635328316972979183761952842010806304748313326215619695085380586052550443025074501971925005072999275628549710915357400946408857mm = crt(m,x)[0]print(long_to_bytes(mm%p))#b&quot;A treasure map is a map that marks the location of buried treasure, a lost mine, a valuable secret or a hidden locale. So flag is afctf&#123;1sn&#x27;t_s0_int3Resting&#125;.&quot;","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"Secret Sharing","slug":"比赛/Secret-Sharing","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/Secret-Sharing/"},{"name":"Shamir&Asmuth-Bloom","slug":"比赛/Secret-Sharing/Shamir-Asmuth-Bloom","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/Secret-Sharing/Shamir-Asmuth-Bloom/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"Secret Sharing","slug":"Secret-Sharing","permalink":"http://example.com/tags/Secret-Sharing/"}]},{"title":"BUU刷题总结（基础）","slug":"BUU刷题总结（一）","date":"2022-02-23T01:53:07.000Z","updated":"2022-03-09T13:15:40.980Z","comments":true,"path":"2022/02/23/BUU刷题总结（一）/","link":"","permalink":"http://example.com/2022/02/23/BUU%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"[WUSTCTF2020]B@se密文：MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD==JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs????kxyz012789+/ oh holy shit, something is missing…","text":"[WUSTCTF2020]B@se密文：MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD==JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs????kxyz012789+/ oh holy shit, something is missing… base64的变异，缺少了四个未知字符，根据base64的字符集来找出缺少的值，并按照排列组合遍历所有可能性；然后将密文在新的base表中的位置带入常见的base64对应表中获得原始字符，最后解base64获得flag。 1234567891011121314151617181920212223242526272829import stringfrom itertools import permutationsfrom base64 import b64decode# s = &quot;JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs****kxyz012789+/&quot;# for i in string.ascii_letters + string.digits:# if(i not in s):# print (i,end=&#x27;&#x27;)#ju34table = &#x27;JASGBWcQPRXEFLbCDIlmnHUVKTYZdMovwipatNOefghq56rs****kxyz012789+/&#x27;#print(table.find(&#x27;*&#x27;)) 48print(len(table))raw_table = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;c = &#x27;MyLkTaP3FaA7KOWjTmKkVjWjVzKjdeNvTnAjoH9iZOIvTeHbvD&#x27;list1 = []for i in permutations(&#x27;ju34&#x27;, 4):#遍历全排列 j = i[0]+i[1]+i[2]+i[3] list1.append(j)for ii in list1: flag = &#x27;&#x27; new_table = table.replace(&quot;****&quot;,ii) for s in c: flag = flag + raw_table[new_table.find(s)] flag = flag + &quot;==&quot; flag = b64decode(flag) if b&quot;ctf&quot; or b&quot;CTF&quot; in flag: print(flag) #wctf2220&#123;base64_1s_v3ry_e@sy_and_fuN&#125; [RoarCTF2019]babyRSA威尔逊定理的考查，做过类似的题。 12345678910111213141516171819202122232425import sympyimport randomdef myGetPrime(): A= getPrime(513) print(A) B=A-random.randint(1e3,1e5) print(B) return sympy.nextPrime((B!)%A)p=myGetPrime()#A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407#B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596q=myGetPrime()#A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927#B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026r=myGetPrime()n=p*q*r#n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733c=pow(flag,e,n)#e=0x1001#c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428#so,what is the flag? exp： 1234567891011121314151617181920212223242526import sympyimport gmpy2A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026e=0x1001c=75700883021669577739329316795450706204502635802310731477156998834710820770245219468703245302009998932067080383977560299708060476222089630209972629755965140317526034680452483360917378812244365884527186056341888615564335560765053550155758362271622330017433403027261127561225585912484777829588501213961110690451987625502701331485141639684356427316905122995759825241133872734362716041819819948645662803292418802204430874521342108413623635150475963121220095236776428n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733def mydecrypt(A,B): g = 1 for i in range(B+1,A-1): g = g*i % A #这里做一次模运算会减少运算量（细节） return gmpy2.invert(g,A)p=sympy.nextprime(mydecrypt(A1,B1))q=sympy.nextprime(mydecrypt(A2,B2))r=n//p//qphi=(p-1)*(q-1)*(r-1)d=gmpy2.invert(e,phi)flag=gmpy2.powmod(c,d,n)import binasciiprint(binascii.unhexlify(hex(flag)[2:]))#RoarCTF&#123;wm-CongrAtu1ation4-1t4-ju4t-A-bAby-R4A&#125; [NCTF2019]babyRSA123456789101112131415161718from Crypto.Util.number import *from flag import flagdef nextPrime(n): n += 2 if n &amp; 1 else 1 while not isPrime(n): n += 2 return np = getPrime(1024)q = nextPrime(p)n = p * qe = 0x10001d = inverse(e, (p-1) * (q-1))c = pow(bytes_to_long(flag.encode()), e, n)# d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913# c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804 题目给了c、d、e但没有n，因此需要想办法求出n，具体来说，可以通过ed和phi（n）的关系推导出p、q，再计算n。通过加密算法大体可以知道,p,q是1024位的,因此两者相乘不低于2048位,通过运算可知ed-1为2064位,因此k介于2^15到2^17之间，因此可以在小范围内对k进行遍历。最后，对phi（n）开方的结果比较接近于p、q，可以在这个值附近取质数。 exp： 123456789101112131415161718192021e=0x10001d = 19275778946037899718035455438175509175723911466127462154506916564101519923603308900331427601983476886255849200332374081996442976307058597390881168155862238533018621944733299208108185814179466844504468163200369996564265921022888670062554504758512453217434777820468049494313818291727050400752551716550403647148197148884408264686846693842118387217753516963449753809860354047619256787869400297858568139700396567519469825398575103885487624463424429913017729585620877168171603444111464692841379661112075123399343270610272287865200880398193573260848268633461983435015031227070217852728240847398084414687146397303110709214913c = 5382723168073828110696168558294206681757991149022777821127563301413483223874527233300721180839298617076705685041174247415826157096583055069337393987892262764211225227035880754417457056723909135525244957935906902665679777101130111392780237502928656225705262431431953003520093932924375902111280077255205118217436744112064069429678632923259898627997145803892753989255615273140300021040654505901442787810653626524305706316663169341797205752938755590056568986738227803487467274114398257187962140796551136220532809687606867385639367743705527511680719955380746377631156468689844150878381460560990755652899449340045313521804import sympy.cryptoimport gmpy2e_d_1=e*d-1p=0q=0for k in range(pow(2,15),pow(2,17)): if e_d_1%k==0: p=sympy.prevprime(gmpy2.iroot(e_d_1//k,2)[0]) q=sympy.nextprime(p) if (p-1)*(q-1)*k==e_d_1: breakn=p*qprint(n)m=gmpy2.powmod(c,d,n)print(m)import binasciiprint(binascii.unhexlify(hex(m)[2:]))#NCTF&#123;70u2_nn47h_14_v3ry_gOO0000000d&#125; [WUSTCTF2020]大数计算 12345678910111213import sympypart1 = hex(int(str(sympy.factorial(2020))[:8],10))[2:]print(part1)part2 = hex(int(str(pow(520,1314)+pow(2333,666))[:8]))[2:]print(part2)#宇宙终极问题的为 三个整数的立方根等于42，求三个数#百度得 -80538738812075974，80435758145817515，12602123297335631part3 = hex(int(str(80538738812075974+80435758145817515+12602123297335631)[:8]))[2:]print(part3)part4 = hex((pow(22,2)+36)*1314)[2:]print(&#x27;wctf2020&#x27;+&#x27;&#123;&#x27;+part1+&#x27;-&#x27;+part2+&#x27;-&#x27;+part3+&quot;-&quot;+part4+&#x27;&#125;&#x27;)#wctf2020&#123;24d231f-403cfd3-108db5e-a6d10&#125; [网鼎杯 2020 青龙组]you_raise_me_up12345678910111213#!/usr/bin/env python# -*- coding: utf-8 -*-from Crypto.Util.number import *import randomn = 2 ** 512m = random.randint(2, n-1) | 1c = pow(m, bytes_to_long(flag), n)print &#x27;m = &#x27; + str(m)print &#x27;c = &#x27; + str(c)# m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075# c = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499 离散对数求解问题： 1flag=sympy.discrete_log(2**512,c,m) #可用sympy库下的discrete_log 1234567891011m = 391190709124527428959489662565274039318305952172936859403855079581402770986890308469084735451207885386318986881041563704825943945069343345307381099559075c = 6665851394203214245856789450723658632520816791621796775909766895233000234023642878786025644953797995373211308485605397024123180085924117610802485972584499n = 2 ** 512import sympyflag=sympy.discrete_log(2**512,c,m)import binasciiprint(binascii.unhexlify(hex(flag)[2:]))#将答案的十六进制转出来就行print(binascii.a2b_hex(hex(flag)[2:]))#flag&#123;5f95ca93-1594-762d-ed0b-a9139692cb4a&#125; RSA &amp; what题目第一部分求解就是共模攻击，解出来的结果是一串由\\n隔开的base64编码，解码出来不是flag；进一步了解知道是base64隐写。 base64隐写学习：https://blog.csdn.net/xnightmare/article/details/103774379 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394from Crypto.Util.number import*import base64def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def CMA(n,e1,e2,c1,c2): s = egcd(e1, e2) s1 = s[1] s2 = s[2] if s1&lt;0: s1 = - s1 c1 = inverse(c1, n) elif s2&lt;0: s2 = - s2 c2 = inverse(c2, n) m = pow(c1,s1,n)*pow(c2,s2,n) % n return mf1=open(&quot;HUB1&quot;)f2=open(&quot;HUB2&quot;)N=f1.readline()N=f2.readline()e1,e2=f1.readline(),f2.readline()f1.readline()f2.readline()c1,c2=f1.readline(),f2.readline()ans=b&#x27;&#x27;cnt=0while len(c1)!=0: cnt+=1 ans+=long_to_bytes(CMA(int(N),int(e1),int(e2),int(c1),int(c2))) #print(base64.b64decode(temp)) c1,c2=f1.readline(),f2.readline()temp=b&#x27;&#x27;M=b&#x27;&#x27;print(ans)for i in ans: k=long_to_bytes(i) if k==b&#x27;\\n&#x27;:#除去回车分隔符 M+=base64.b64decode(temp) temp=b&#x27;&#x27; continue temp+=kprint(M)from Crypto.Util.number import*import base64c = b&#x27;VEhJUz==\\nRkxBR3==\\nSVN=\\nSElEREVOLo==\\nQ0FO\\nWU9V\\nRklORM==\\nSVT=\\nT1VUP4==\\nRE8=\\nWU9V\\nS05PV9==\\nQkFTRTY0P5==\\nWW91bmdD\\nVEhJTku=\\nWU9V\\nQVJF\\nTk9U\\nVEhBVE==\\nRkFNSUxJQVI=\\nV0lUSO==\\nQkFTRTY0Lh==\\nQmFzZTY0\\naXO=\\nYW==\\nZ3JvdXA=\\nb2b=\\nc2ltaWxhcn==\\nYmluYXJ5LXRvLXRleHR=\\nZW5jb2Rpbme=\\nc2NoZW1lc0==\\ndGhhdD==\\ncmVwcmVzZW50\\nYmluYXJ5\\nZGF0YW==\\naW5=\\nYW6=\\nQVNDSUl=\\nc3RyaW5n\\nZm9ybWF0\\nYnk=\\ndHJhbnNsYXRpbmd=\\naXS=\\naW50b1==\\nYT==\\ncmFkaXgtNjQ=\\ncmVwcmVzZW50YXRpb24u\\nVGhl\\ndGVybc==\\nQmFzZTY0\\nb3JpZ2luYXRlc8==\\nZnJvbd==\\nYY==\\nc3BlY2lmaWN=\\nTUlNRT==\\nY29udGVudI==\\ndHJhbnNmZXI=\\nZW5jb2Rpbmcu\\nVGhl\\ncGFydGljdWxhct==\\nc2V0\\nb2b=\\nNjR=\\nY2hhcmFjdGVyc5==\\nY2hvc2Vu\\ndG+=\\ncmVwcmVzZW50\\ndGhl\\nNjQ=\\ncGxhY2UtdmFsdWVz\\nZm9y\\ndGhl\\nYmFzZd==\\ndmFyaWVz\\nYmV0d2Vlbt==\\naW1wbGVtZW50YXRpb25zLp==\\nVGhl\\nZ2VuZXJhbI==\\nc3RyYXRlZ3n=\\naXO=\\ndG9=\\nY2hvb3Nl\\nNjR=\\nY2hhcmFjdGVyc5==\\ndGhhdA==\\nYXJl\\nYm90aN==\\nbWVtYmVyc5==\\nb2a=\\nYS==\\nc3Vic2V0\\nY29tbW9u\\ndG8=\\nbW9zdM==\\nZW5jb2RpbmdzLA==\\nYW5k\\nYWxzb8==\\ncHJpbnRhYmxlLg==\\nVGhpc9==\\nY29tYmluYXRpb25=\\nbGVhdmVz\\ndGhl\\nZGF0YW==\\ndW5saWtlbHk=\\ndG/=\\nYmV=\\nbW9kaWZpZWS=\\naW5=\\ndHJhbnNpdE==\\ndGhyb3VnaN==\\naW5mb3JtYXRpb26=\\nc3lzdGVtcyw=\\nc3VjaN==\\nYXM=\\nRS1tYWlsLD==\\ndGhhdA==\\nd2VyZQ==\\ndHJhZGl0aW9uYWxseQ==\\nbm90\\nOC1iaXQ=\\nY2xlYW4uWzFd\\nRm9y\\nZXhhbXBsZSw=\\nTUlNRSdz\\nQmFzZTY0\\naW1wbGVtZW50YXRpb24=\\ndXNlcw==\\nQahDWiw=\\nYahDeiw=\\nYW5k\\nMKhDOQ==\\nZm9y\\ndGhl\\nZmlyc3Q=\\nNjI=\\ndmFsdWVzLg==\\nT3RoZXI=\\ndmFyaWF0aW9ucw==\\nc2hhcmU=\\ndGhpcw==\\ncHJvcGVydHk=\\nYnV0\\nZGlmZmVy\\naW4=\\ndGhl\\nc3ltYm9scw==\\nY2hvc2Vu\\nZm9y\\ndGhl\\nbGFzdA==\\ndHdv\\ndmFsdWVzOw==\\nYW4=\\nZXhhbXBsZQ==\\naXM=\\nVVRGLTcu&#x27;def get_base64_diff_value(s1, s2): base64chars = b&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27; res = 0 for i in range(len(s2)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): line=b&#x27;&#x27; bin_str=&#x27;&#x27; for i in c: k=long_to_bytes(i) if k==b&#x27;\\n&#x27;: steg_line = line norm_line = base64.b64encode(base64.b64decode(line)) diff = get_base64_diff_value(steg_line, norm_line) print(norm_line) print(steg_line) print(diff) pads_num = steg_line.count(b&#x27;=&#x27;) if diff: print(bin(diff)) bin_str += bin(diff)[2:].zfill(pads_num * 2) #zfill右对齐 else: bin_str += &#x27;0&#x27; * pads_num * 2 print(goflag(bin_str)) line=b&#x27;&#x27; continue line+=kdef goflag(bin_str): res_str = &#x27;&#x27; for i in range(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i + 8], 2)) return res_strif __name__ == &#x27;__main__&#x27;: solve_stego() [MRCTF2020]babyRSA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import sympyimport randomfrom gmpy2 import gcd, invertfrom Crypto.Util.number import getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytesfrom z3 import *flag = b&quot;MRCTF&#123;xxxx&#125;&quot;base = 65537def GCD(A): B = 1 for i in range(1, len(A)): B = gcd(A[i-1], A[i]) return Bdef gen_p(): P = [0 for i in range(17)] P[0] = getPrime(128) for i in range(1, 17): P[i] = sympy.nextprime(P[i-1])#一连串连续的质数 print(&quot;P_p :&quot;, P[9]) n = 1 for i in range(17): n *= P[i] p = getPrime(1024) factor = pow(p, base, n) print(&quot;P_factor :&quot;, factor) return sympy.nextprime(p)def gen_q(): sub_Q = getPrime(1024) Q_1 = getPrime(1024) Q_2 = getPrime(1024) Q = sub_Q ** Q_2 % Q_1 print(&quot;Q_1: &quot;, Q_1) print(&quot;Q_2: &quot;, Q_2) print(&quot;sub_Q: &quot;, sub_Q) return sympy.nextprime(Q)if __name__ == &quot;__main__&quot;: _E = base _P = gen_p() _Q = gen_q() assert (gcd(_E, (_P - 1) * (_Q - 1)) == 1) _M = bytes_to_long(flag) _C = pow(_M, _E, _P * _Q) print(&quot;Ciphertext = &quot;, _C)&#x27;&#x27;&#x27;P_p : 206027926847308612719677572554991143421P_factor : 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839Q_1: 103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521Q_2: 151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743sub_Q: 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651Ciphertext = 1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832&#x27;&#x27;&#x27; 伪随机数的预测，exp： 123456789101112131415161718192021222324252627282930313233343536from Crypto.Util.number import *import sympyimport gmpy2base = 65537l1 = []P_p = 206027926847308612719677572554991143421for i in range(0,17): l1.append(0)l1[9] = P_pfor i in range(10,17): l1[i] = sympy.nextprime(l1[i-1])for i in range(9): l1[9-i-1] = sympy.prevprime(l1[9-i])print(l1)n = 1phi=1for j in range(17): n *= l1[j] phi*=(l1[j]-1)P_factor = 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839d = gmpy2.invert(base,phi)p = pow(P_factor,d,n)#加密用的p是下边这个_p = sympy.nextprime(p)Q_1 = 103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521Q_2 = 151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743sub_Q = 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651Ciphertext = 1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832q = pow(sub_Q,Q_2,Q_1)_q = sympy.nextprime(q)_phi = (_q-1)*(_p-1)_d = gmpy2.invert(base,_phi)print(long_to_bytes(pow(Ciphertext,_d,_p*_q)))#MRCTF&#123;sti11_@_b@by_qu3st10n&#125; [NPUCTF2020]EzRSA12345678910111213141516171819from gmpy2 import lcm , powmod , invert , gcd , mpzfrom Crypto.Util.number import getPrimefrom sympy import nextprimefrom random import randintp = getPrime(1024)q = getPrime(1024)n = p * qgift = lcm(p - 1 , q - 1)#求最小公倍数e = 54722flag = b&#x27;NPUCTF&#123;******************&#125;&#x27;m = int.from_bytes(flag , &#x27;big&#x27;)c = powmod(m , e , n)print(&#x27;n: &#x27; , n)print(&#x27;gift: &#x27; , gift)print(&#x27;c: &#x27; , c)#n: 17083941230213489700426636484487738282426471494607098847295335339638177583685457921198569105417734668692072727759139358207667248703952436680183153327606147421932365889983347282046439156176685765143620637107347870401946946501620531665573668068349080410807996582297505889946205052879002028936125315312256470583622913646319779125559691270916064588684997382451412747432722966919513413709987353038375477178385125453567111965259721484997156799355617642131569095810304077131053588483057244340742751804935494087687363416921314041547093118565767609667033859583125275322077617576783247853718516166743858265291135353895239981121#gift: 2135492653776686212553329560560967285303308936825887355911916917454772197960682240149821138177216833586509090969892419775958406087994054585022894165950768427741545736247918410255804894522085720642952579638418483800243368312702566458196708508543635051350999572787188236243275631609875253617015664414032058822919469443284453403064076232765024248435543326597418851751586308514540124571309152787559712950209357825576896132278045112177910266019741013995106579484868768251084453338417115483515132869594712162052362083414163954681306259137057581036657441897428432575924018950961141822554251369262248368899977337886190114104#c: 3738960639194737957667684143565005503596276451617922474669745529299929395507971435311181578387223323429323286927370576955078618335757508161263585164126047545413028829873269342924092339298957635079736446851837414357757312525158356579607212496060244403765822636515347192211817658170822313646743520831977673861869637519843133863288550058359429455052676323196728280408508614527953057214779165450356577820378810467527006377296194102671360302059901897977339728292345132827184227155061326328585640019916328847372295754472832318258636054663091475801235050657401857262960415898483713074139212596685365780269667500271108538319 gift = lcm(p - 1 , q - 1)是解题的关键，p-1和q-1的最小公倍数实际上等于（p-1）*（q-1）除以两者的最大公因数；而p-1和q-1都是偶数（有公因子2），所以（p-1）和（q-1）的乘积等于最小公倍数乘2的倍数，不断尝试发现max公因子为8。 123456789101112131415from gmpy2 import invert,irootfrom Crypto.Util.number import *n=17083941230213489700426636484487738282426471494607098847295335339638177583685457921198569105417734668692072727759139358207667248703952436680183153327606147421932365889983347282046439156176685765143620637107347870401946946501620531665573668068349080410807996582297505889946205052879002028936125315312256470583622913646319779125559691270916064588684997382451412747432722966919513413709987353038375477178385125453567111965259721484997156799355617642131569095810304077131053588483057244340742751804935494087687363416921314041547093118565767609667033859583125275322077617576783247853718516166743858265291135353895239981121gift=2135492653776686212553329560560967285303308936825887355911916917454772197960682240149821138177216833586509090969892419775958406087994054585022894165950768427741545736247918410255804894522085720642952579638418483800243368312702566458196708508543635051350999572787188236243275631609875253617015664414032058822919469443284453403064076232765024248435543326597418851751586308514540124571309152787559712950209357825576896132278045112177910266019741013995106579484868768251084453338417115483515132869594712162052362083414163954681306259137057581036657441897428432575924018950961141822554251369262248368899977337886190114104c=3738960639194737957667684143565005503596276451617922474669745529299929395507971435311181578387223323429323286927370576955078618335757508161263585164126047545413028829873269342924092339298957635079736446851837414357757312525158356579607212496060244403765822636515347192211817658170822313646743520831977673861869637519843133863288550058359429455052676323196728280408508614527953057214779165450356577820378810467527006377296194102671360302059901897977339728292345132827184227155061326328585640019916328847372295754472832318258636054663091475801235050657401857262960415898483713074139212596685365780269667500271108538319e = 54722phi=gift*8e=e//2 #e化简为质数，因为e必须和phi互素d=invert(e,phi)m=pow(c,int(d),n)mm=iroot(m,2)[0]print (long_to_bytes(mm))#NPUCTF&#123;diff1cult_rsa_1s_e@sy&#125; [ACTF新生赛2020]crypto-classic1维吉尼亚密码，先求key再解密： 12345678910111213141516171819202122232425262728import string# 破解keys = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;s1 = &#x27;ACTF&#x27;s2 = &#x27;SRLU&#x27;key = &#x27;&#x27;for i in range(len(s1)): key += s[(s.find(s2[i]) - s.find(s1[i])) % 26]print(key)# 解密cipher = &#x27;SRLU&#123;LZPL_S_UASHKXUPD_NXYTFTJT&#125;&#x27;key = &#x27;SP&#x27;# decodetable = string.ascii_uppercaseprint(table)flag = &#x27;&#x27;for i in range(0, len(cipher)): if cipher[i] == &#x27;&#123;&#x27;: flag += &quot;&#123;&quot; elif cipher[i] == &#x27;_&#x27;: flag += &quot;_&quot; elif cipher[i] == &#x27;&#125;&#x27;: flag += &quot;&#125;&quot; else: flag += table[(table.find(cipher[i]) + 26 - table.find(key[i % len(key)])) % 26]print(flag.lower())#actf&#123;what_a_classical_vigenere&#125; [BJDCTF2020]Polybiuspolypius加密，exp： 123456789101112131415161718192021import itertoolskey = []cipher = &quot;ouauuuoooeeaaiaeauieuooeeiea&quot;for i in itertools.permutations(&#x27;aeiou&#x27;, 5): key.append(&#x27;&#x27;.join(i))for now_key in key: solve_c = &quot;&quot; res = &quot;&quot; for now_c in cipher: solve_c += str(now_key.index(now_c)) for i in range(0,len(solve_c),2): now_ascii = int(solve_c[i])*5+int(solve_c[i+1])+97 if now_ascii&gt;ord(&#x27;i&#x27;): now_ascii+=1 res += chr(now_ascii) if &quot;flag&quot; in res: print (now_key,res) #uoaei flagispolybius [MRCTF2020]Easy_RSA总结经验两点： 1.z3库可用来解rsa的p、q联立的方程 2.ed-1//n和ed-1//phi非常接近，通常只差1或者2 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243from z3 import *import sympyimport gmpy2from Crypto.Util.number import long_to_bytesP_n = 14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024336556028267742021320891681762543660468484018686865891073110757394154024833552558863671537491089957038648328973790692356014778420333896705595252711514117478072828880198506187667924020260600124717243067420876363980538994101929437978668709128652587073901337310278665778299513763593234951137512120572797739181693P_F_n = 14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024099427363967321110127562039879018616082926935567951378185280882426903064598376668106616694623540074057210432790309571018778281723710994930151635857933293394780142192586806292968028305922173313521186946635709194350912242693822450297748434301924950358561859804256788098033426537956252964976682327991427626735740Q_n = 20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947Q_E_D = 100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201Ciphertext = 40855937355228438525361161524441274634175356845950884889338630813182607485910094677909779126550263304194796000904384775495000943424070396334435810126536165332565417336797036611773382728344687175253081047586602838685027428292621557914514629024324794275772522013126464926990620140406412999485728750385876868115091735425577555027394033416643032644774339644654011686716639760512353355719065795222201167219831780961308225780478482467294410828543488412258764446494815238766185728454416691898859462532083437213793104823759147317613637881419787581920745151430394526712790608442960106537539121880514269830696341737507717448946962021#getpsum_pq = P_n - P_F_n +1p1 = Int(&quot;p&quot;)q1 = Int(&quot;q&quot;)#solve(p1*q1 == P_n,p1+q1 == sum_pq)p_1 = 118153578345562250550767057731385782963063734586321112579869747650001448473633860305142281504862521928246520876300707405515141444727550839066835195905927281903880307860942630322499106164191736174201506457157272220802515607939618476716593888428832962374494147723577980992661629254713116923690067827155668889571q_1 = 118975085954858660642562584152139261422493348532593400307960127317249511761542030451912561362687361053191375307180413931721355251895350936376781657674896801388806379750757264377396608174235075021854614328009897408824235800167369204203680938298803752964983358298299699273425596382268869237139724754214443556383factor2 = 2021 * p_1 + 2020 * q_1p = sympy.nextprime(factor2)#getqk = (Q_E_D-1)//Q_nQ_F_n = (Q_E_D-1)//(k+1)print((k+1)*Q_F_n == Q_E_D-1)#验证Q_E_D-1除以k+1是否等于p*qsum_qp = Q_n - Q_F_n +1p2 = Int(&quot;p&quot;)q2 = Int(&quot;q&quot;)# solve(p2*q2 == Q_n,p2+q2 == sum_qp)p_2 = 120538849514661970159855851547577637711900368732462953774738483480759950867244867240401273864984981385806453735655967797329769252143125966966236767391995563418243748302685348336642872306042286401427581501609713577329945760930395130411743322595026287853073310150103535873078436896035943385067893062698858976291q_2 = 171847486694659608706336923173786708071603689972942289760669690002615525263534483261477699540482615520223300780778172120221008417518590133753701145591943840552802072474293556608389677806415392384924913911677288126066245025731416399656855625839288752326267741979436855441260177305707529456715625062080892327017factor1 = 2021 * p_2 - 2020 * q_2print(-factor1)q = sympy.nextprime(-factor1)print(p)print(q)#flage = 65537phi = (p-1)*(q-1)n = p*qd = gmpy2.invert(e,phi)print(long_to_bytes(pow(Ciphertext,d,n)))#MRCTF&#123;Ju3t_@_31mp13_que3t10n&#125; [ACTF2020]crypto-aes12345678910111213from Cryptodome.Cipher import AESfrom Crypto.Util.number import *xor = 91144196586662942563895769614300232343026691029427747065707381728622849079757c = b&#x27;\\x8c-\\xcd\\xde\\xa7\\xe9\\x7f.b\\x8aKs\\xf1\\xba\\xc75\\xc4d\\x13\\x07\\xac\\xa4&amp;\\xd6\\x91\\xfe\\xf3\\x14\\x10|\\xf8p&#x27;out = long_to_bytes(xor)key = out[:16]*2print(key)iv = bytes_to_long(key[:16]) ^ bytes_to_long(out[16:])aes=AES.new(key,AES.MODE_CBC,long_to_bytes(iv))flag = aes.decrypt(c)print(flag)#actf&#123;W0W_y0u_can_so1v3_AES_now!&#125; [UTCTF2020]hill希尔密码，直接去爆破逆矩阵就行了。 12345678910111213141516171819import strings=&#x27;wznqcaduqopfkqnwofDbzgeu&#x27;flag_pre=&#x27;utflag&#x27;def getit(a1,b1,c1,a2,b2,c2,a3,b3,c3): for i in range(26): for j in range(26): if (a1 * i + b1 * j) % 26 == c1 and (a2 * i + b2 * j) % 26 == c2 and (a3 * i+b3*j) % 26 == c3: return (i,j)x1=getit(22,25,20,13,16,5,2,0,0)print(x1)x2=getit(22,25,19,13,16,11,2,0,6)print(x2)flag=&#x27;&#x27;for i in range(0, len(s),2): flag+=string.ascii_letters[(x1[0]*string.ascii_letters.index(s[i])+x1[1]*string.ascii_letters.index(s[i+1]))%26] flag+=string.ascii_letters[(x2[0]*string.ascii_letters.index(s[i])+x2[1]*string.ascii_letters.index(s[i+1]))%26]print(flag)#utflag&#123;d4nger0us_c1pherText_qq&#125; 将大小写，数字等补回去 [NPUCTF2020]认清形势，建立信心12345678910111213141516171819202122from Crypto.Util.number import *from gmpy2 import *from secret import flagp = getPrime(25)e = # Hiddenq = getPrime(25)n = p * qm = bytes_to_long(flag.strip(b&quot;npuctf&#123;&quot;).strip(b&quot;&#125;&quot;))c = pow(m, e, n)print(c)print(pow(2, e, n))print(pow(4, e, n))print(pow(8, e, n))&#x27;&#x27;&#x27;169169912654178128509160179202518818742414340358553002064450&#x27;&#x27;&#x27; exp： 12345678910111213141516c=169169912654178a1=128509160179202a2=518818742414340a3=358553002064450import gmpy2print(gmpy2.gcd(a1**2-a2,a1*a2-a3))#gcd(a1**2-a2,a1*a2-a3)就为n的k倍，这个数很小，拿去大数分解p=18195301q=28977097n=p*qimport sympye=sympy.discrete_log(n,a1,2)d=gmpy2.invert(e,(p-1)*(q-1))import Crypto.Util.numberprint(Crypto.Util.number.long_to_bytes(gmpy2.powmod(c,d,n)))#flag&#123;345y!&#125; [AFCTF2018]Tiny LFSR只需要异或求出key就可以利用lfsr序列进行解密，不需要逆推反馈移位寄存器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748with open(&quot;cipher.txt&quot;,&quot;rb&quot;) as ff: key_or = ff.readline()with open(&quot;Plain.txt&quot;,&quot;r&quot;) as p: plain = p.readline()key_or = key_or[:len(key_or)-2]print(key_or)print(len(key_or))print(len(plain))key = &#x27;&#x27;for i in range(len(key_or)): print(hex((key_or[i] ^ ord(plain[i])))[2:],end=&#x27;&#x27;)#按一个字节存储的时候，大小端储存的结果一样import os,sysos.chdir(sys.path[0])key = &#x27;0123456789abcdef&#x27;R = int(key,16)mask = 0b1101100000000000000000000000000000000000000000000000000000000000def lfsr(R, mask): output = (R &lt;&lt; 1) &amp; 0xffffffffffffffff i=(R&amp;mask)&amp;0xffffffffffffffff lastbit=0 while i!=0: lastbit^=(i&amp;1) i=i&gt;&gt;1 output^=lastbit return (output,lastbit)cipher = open(&#x27;flag_encode.txt&#x27;,&#x27;rb&#x27;).read()a = &#x27;&#x27;.join([chr(int(b, 16)) for b in [key[i:i+2] for i in range(0, len(key), 2)]])ans = []lent = len(cipher)for i in range(0, len(a)): ans.append(chr(cipher[i]^ord(a[i])))for i in range(len(a), lent): tmp = 0 for j in range(8): (R,out)=lfsr(R,mask) tmp=(tmp &lt;&lt; 1)^out ans.append(chr(tmp ^ cipher[i]))flag = &#x27;&#x27;.join(ans)print(flag)# afctf&#123;read_is_hard_but_worthy&#125; [ACTF新生赛2020]crypto-des根据提示压缩包密码可以通过数据类型转换转换成c语言的标准浮点数存储格式，然后再转成hex，最后把hex转化成字符串： 12345678910111213141516171819202122from libnum import*import structimport binasciis = [72143238992041641000000.000000,77135357178006504000000000000000.000000,1125868345616435400000000.000000,67378029765916820000000.000000,75553486092184703000000000000.000000,4397611913739958700000.000000,76209378028621039000000000000000.000000]a = &#x27;&#x27;b = &#x27;&#x27;for i in s: i = float(i) a += struct.pack(&#x27;&lt;f&#x27;,i).hex() #小端print(a)for j in s: i = float(i) b += struct.pack(&#x27;&gt;f&#x27;,i).hex() #小端print(b)a = 0x496e74657265737472696e67204964656120746f20656e6372797074b = 0x74707972747079727470797274707972747079727470797274707972print(n2s(a))print(n2s(b))#Interestring Idea to encrypt 解压得到加密脚本，已经给了轮密钥，直接解密即可。 1234567891011121314151617181920212223242526272829303132import pyDesimport base64deskey = &quot;00000000&quot;DES = pyDes.des(deskey)DES.setMode(&#x27;ECB&#x27;)DES.Kn = [ [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1] ]# cipher_list = base64.b64encode(DES.encrypt(flag))k = b&#x27;vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo&#x27;data = base64.b64decode(k)print(data)flag = DES.decrypt(data)print(flag)#actf&#123;breaking_DES_is_just_a_small_piece_of_cake&#125; [SUCTF2019]MT刷到了自己战队老师傅出的题了^-^。这题可以用z3来逆运算，或者手动推导关系，但是这样太慢并且复杂，有师傅给出了一个新奇的思路，那就是把密文进行多轮加密，经过足够多次数以后就会得到明文。这种做法可以理解为：对某一固定长度的字符串进行移位和异或两种操作，其密文空间是有限的，因此只要不断加密就能得到明文。不知道算不算非预期。 1234567891011121314151617181920212223242526from Crypto.Random import randomfrom Crypto.Util import numberfrom flag import flag#优先移位再与再异或def convert(m): m = m ^ m &gt;&gt; 13 m = m ^ m &lt;&lt; 9 &amp; 2029229568 m = m ^ m &lt;&lt; 17 &amp; 2245263360 m = m ^ m &gt;&gt; 19 return mdef transform(message): assert len(message) % 4 == 0 new_message = &#x27;&#x27; for i in range(len(message) / 4): block = message[i * 4 : i * 4 +4] block = number.bytes_to_long(block) block = convert(block) block = number.long_to_bytes(block, 4)#补充为4字节？ new_message += block return new_messagetransformed_flag = transform(flag[5:-1].decode(&#x27;hex&#x27;)).encode(&#x27;hex&#x27;)print &#x27;transformed_flag:&#x27;, transformed_flag# transformed_flag: 641460a9e3953b1aaa21f3a2 exp： 123456789101112131415161718192021222324252627282930313233343536from Crypto.Util import numberdef convert(m): #异或与运算（字节型） m = m ^ m &gt;&gt; 13 m = m ^ m &lt;&lt; 9 &amp; 2029229568 m = m ^ m &lt;&lt; 17 &amp; 2245263360 m = m ^ m &gt;&gt; 19 return mdef transform(message): assert len(message) % 4 == 0 new_message = b&#x27;&#x27; for i in range(len(message) // 4): block = message[i * 4 : i * 4 +4] block = number.bytes_to_long(block) block = convert(block) block = number.long_to_bytes(block, 4) new_message += block return new_message#transformed_flag = transform(flag[5:-1].decode(&#x27;hex&#x27;)).encode(&#x27;hex&#x27;) #转为字节型运算 运算完转16进制#print &#x27;transformed_flag:&#x27;, transformed_flag# transformed_flag: 641460a9e3953b1aaa21f3a2# 密文不断加密可得到原文，flag经过一次加密后得到transformed_flagdef decode(c): x = c #将加密的flag段给x while True: x_ = x x = transform(x) #给x加密 if x == c: # 当x_（flag）的下一次加密等于c（transformed_flag ）时 返回x_（flag） return x_transformed_flag = &#x27;641460a9e3953b1aaa21f3a2&#x27;print(bytes.fromhex(transformed_flag))flag = decode(bytes.fromhex(transformed_flag)).hex()print(&#x27;flag:&#x27;, flag)#(&#x27;flag:&#x27;, &#x27;84b45f89af22ce7e67275bdc&#x27;)","categories":[{"name":"buu","slug":"buu","permalink":"http://example.com/categories/buu/"},{"name":"刷题总结","slug":"buu/刷题总结","permalink":"http://example.com/categories/buu/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"buu","slug":"buu","permalink":"http://example.com/tags/buu/"}]},{"title":"HSC-1th 2022","slug":"HSC-1th-2022","date":"2022-02-21T02:35:19.000Z","updated":"2022-02-21T02:44:35.583Z","comments":true,"path":"2022/02/21/HSC-1th-2022/","link":"","permalink":"http://example.com/2022/02/21/HSC-1th-2022/","excerpt":"","text":"​ 这比赛挺不错的，题目难度有梯度，对萌新友好。 ​ 最终Rank：10 ​ 解题情况： ​ ​ ​ wp： ​ 链接：https://pan.baidu.com/s/1bFoBiAGf_iVadnklT59VLQ​ 提取码：2678","categories":[{"name":"赛事","slug":"赛事","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/"},{"name":"HSC-1th 2022","slug":"赛事/HSC-1th-2022","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/HSC-1th-2022/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"赛事","slug":"赛事","permalink":"http://example.com/tags/%E8%B5%9B%E4%BA%8B/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"},{"name":"misc","slug":"misc","permalink":"http://example.com/tags/misc/"},{"name":"re","slug":"re","permalink":"http://example.com/tags/re/"}]},{"title":"RSA-DP泄露（二）","slug":"RSA-DP泄露（二）","date":"2022-02-17T02:37:13.000Z","updated":"2022-02-17T08:25:19.111Z","comments":true,"path":"2022/02/17/RSA-DP泄露（二）/","link":"","permalink":"http://example.com/2022/02/17/RSA-DP%E6%B3%84%E9%9C%B2%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"​ 附件： 12345p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852","text":"​ 附件： 12345p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 ​ 推导： ​ exp： 12345678910111213import gmpy2p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852I = gmpy2.invert(q,p)m1 = pow(c,dp,p)m2 = pow(c,dq,q)m = (((m1-m2)*I)%p)*q+m2print(m) #10进制明文print(hex(m)[2:]) #16进制明文print(bytes.fromhex(hex(m)[2:])) #16进制转文本","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"RSA","slug":"比赛/RSA","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/"},{"name":"数论或其它","slug":"比赛/RSA/数论或其它","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/%E6%95%B0%E8%AE%BA%E6%88%96%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"VNCTF2022","slug":"VNCTF2022","date":"2022-02-12T07:26:21.000Z","updated":"2022-02-17T08:23:20.418Z","comments":true,"path":"2022/02/12/VNCTF2022/","link":"","permalink":"http://example.com/2022/02/12/VNCTF2022/","excerpt":"​ 今天和队友搞美赛模拟，就签了个到（其实是我太菜了），后边面向wp学习吧 QAQ。","text":"​ 今天和队友搞美赛模拟，就签了个到（其实是我太菜了），后边面向wp学习吧 QAQ。 Rank 77/717 WebGameV4.0一堆js文件，源码找注释，base64解码。 Misc仔细找找​ 仔细观察会发现黑色背景部分有很多彩色小点，用ps打开调节亮度并调整视图可以看到flag。 Cryptoezmath12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from Crypto.Util.number import*import randomfrom secret import flag,checkfrom hashlib import sha256import socketserverimport signalimport string table = string.ascii_letters+string.digits #所有字母和0-9class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b&#x27;&#x27; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) &lt; BUFF_SIZE: break return data.strip() #除去首尾空格 def send(self, msg, newline=True): try: if newline: msg += b&#x27;\\n&#x27; self.request.sendall(msg) except: pass def recv(self, prompt=b&#x27;&#x27;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (&#x27;&#x27;.join([random.choice(table)for _ in range(20)])).encode() sha = sha256(proof).hexdigest().encode() self.send(b&quot;[+] sha256(XXXX+&quot; + proof[4:] + b&quot;) == &quot; + sha ) XXXX = self.recv(prompt = b&#x27;[+] Plz Tell Me XXXX :&#x27;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def handle(self): proof = self.proof_of_work() if not proof: self.request.close() counts = 0 signal.alarm(60) for i in range(777): times = getPrime(32) self.send(b&#x27;plz give me the &#x27; + str(times).encode() + b&#x27;th (n) that satisfying (2^n-1) % 15 == 0:&#x27;) n = int(self.recv()) a , ret = check(times,n) if a == True: self.send(ret.encode()) counts += 1 else: self.send(ret.encode()) if counts == 777: self.send(b&#x27;You get flag!&#x27;) self.send(flag) else: self.send(b&#x27;something wrong?&#x27;) self.request.close()class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): passif __name__ == &quot;__main__&quot;: HOST, PORT = &#x27;0.0.0.0&#x27;, 10001 print(&quot;HOST:POST &quot; + HOST+&quot;:&quot; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() ​ exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding:utf-8 -*-from pwn import *def jm_sha256_single(value): &quot;&quot;&quot; sha256加密 :param value: 加密字符串 :return: 加密结果转换为16进制字符串 &quot;&quot;&quot; hsobj = hashlib.sha256() hsobj.update(value.encode(&quot;utf-8&quot;)) return hsobj.hexdigest().lower()#爆破哈希def send_hash(res,hashs): table = string.ascii_letters + string.digits for i1 in table: for i2 in table : for i3 in table: for i4 in table: s = i1 + i2 + i3 + i4 ss = s + res if jm_sha256_single(ss) == hashs: print(s) io.sendline(s.encode()) return 0def find_n(th): j = 4*th return jif __name__ == &#x27;__main__&#x27;: io = remote(&#x27;node4.buuoj.cn&#x27;,25854) q1 = str(io.recvuntil(&quot;:&quot;.encode())) start1 = q1.find(&#x27;(&#x27;) res = q1[start1+6:start1+22] print(res) start2 = q1.find(&#x27;==&#x27;) hashs = q1[start2+3:start2+67] print(hashs) send_hash(res,hashs) for i in range(777): print(i) q2 = str(io.recvuntil(&#x27;:&#x27;.encode())) print(q2) start3 = q2.find(&#x27;the&#x27;) th = q2[start3+4:start3+14] th = int(th) print(th) n = find_n(th) io.sendline(str(n).encode()) flag = str(io.recvrepeat(timeout=5)) print(flag)#flag&#123;cebdfc71-0a91-4e2e-97cf-70700c7cbcf3&#125; babyPHE（复现）​ 题目描述：Alice最近学习了一种新型加密模式，她想当可信第三方。然额，她发现生成密钥对时间太长了，她使用了固定的密钥对。有六个用户他们使用Alice的密码系统去进行加密，他们使用该系统悄悄的flag混合了。 Bob是Alice的男盆友，他不讲武德在密码系统中偷偷记录了六个用户生成密钥对时的服务器上的某个参数并想要尝试破译，但是他没有破译成功，于是将他有的信息悄悄的发送给了你。 你能恢复出这flag是什么吗 flag’s format : vnctf{ } hint： 快速幂的消耗 ​ 附件1：cryptosystem.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from Crypto.Util.number import*import randomclass CryptoSystem: def __init__(self,kbit) : self.k_bit = kbit self.p_bit = self.k_bit//2 self.q_bit = self.k_bit - self.p_bit self.gen_alice_key() def gen_alice_key(self): while 1: p = getPrime(self.p_bit) p_tmp = (p-1)//2 if isPrime(p_tmp): break while 1: q = getPrime(self.q_bit) q_tmp = (q-1)//2 if isPrime(q_tmp): break N = p * q #大整数难以分解作为公钥 while 1: g = random.randrange(N*N) if (pow(g,p_tmp * q_tmp,N*N) - 1) % N == 0 and \\ (pow(g,p_tmp * q_tmp,N*N) - 1) // N &gt;= 1 and \\ (pow(g,p_tmp * q_tmp,N*N) - 1) // N &lt;= N - 1: break self.alice_pub = (N,g)#公钥 self.alice_sec = (p,q)#私钥 def gen_other_key(self): N,g = self.alice_pub a = random.randrange(N*N) h = pow(g,a,N*N) pub = h sec = a return pub,sec #生成密钥对的算法/ def other_encrypt(self,pk,m): N,g = self.alice_pub r = random.randrange(N*N) A = pow(g,r,N*N) B = (pow(pk,r,N*N) * (1 + m * N)) % (N * N) return A,B def Add(self,dataCipher1,dataCipher2): N , g = self.alice_pub A1,B1 = dataCipher1 A2,B2 = dataCipher2 B = (B1*B2) % (N*N) return (A1,A2,B) ​ 附件2：server.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394from Crypto.Util.number import*from cryptosystem import CryptoSystem from secret import flagimport randomfrom hashlib import sha256import socketserverimport signalimport string table = string.ascii_letters+string.digitsMENU = b&#x27;What do you want to get?\\n[1]the pk list\\n[2]Alice Public Parameters\\n[3]Mixed Flag\\n[4]exit&#x27;class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b&#x27;&#x27; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) &lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b&#x27;\\n&#x27; self.request.sendall(msg) except: pass def recv(self, prompt=b&#x27;SERVER &lt;INPUT&gt;: &#x27;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (&#x27;&#x27;.join([random.choice(table)for _ in range(20)])).encode() sha = sha256(proof).hexdigest().encode() self.send(b&quot;[+] sha256(XXXX+&quot; + proof[4:] + b&quot;) == &quot; + sha ) XXXX = self.recv(prompt = b&#x27;[+] Plz Tell Me XXXX :&#x27;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def gen_participation_key_pair(self): participation_pk_list = [] participation_sk_list = [] for i in range(6): part_pk,part_sk = self.alice_cryptosystem.gen_other_key() #获得6对生成的密钥对 participation_pk_list.append(part_pk) participation_sk_list.append(part_sk) return part_pk def handle(self): self.alice_cryptosystem = CryptoSystem(1024) participation_pk_list = self.gen_participation_key_pair() proof = self.proof_of_work() if not proof: self.request.close() signal.alarm(60) flag_list = [bytes_to_long(flag[i*5:i*5+5]) for i in range(6)] cipher_list = [self.alice_cryptosystem.other_encrypt(participation_pk_list[i],flag_list[i]) for i in range(6)]#这里是在用密码系统生成的公私钥对进行加密 mixed_data = [self.alice_cryptosystem.Add(cipher_list[i],cipher_list[i+1]) for i in range(5)] #同态加密 混合 while 1: self.send(MENU) option = self.recv() if option == b&#x27;1&#x27;: self.send(b&quot;[~]My pk_list is:&quot;) self.send(str(participation_pk_list).encode()) elif option == b&#x27;2&#x27;: self.send(b&quot;[~]Alice public_parameters is&quot;) self.send(str(self.alice_cryptosystem.alice_pub).encode()) elif option == b&#x27;3&#x27;: self.send(b&#x27;[~]What you want is the flag!&#x27;) self.send(str(mixed_data).encode()) else: break self.request.close()class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): passif __name__ == &quot;__main__&quot;: HOST, PORT = &#x27;0.0.0.0&#x27;, 10005 print(&quot;HOST:POST &quot; + HOST+&quot;:&quot; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() ​ 附件3：Bob_give_you_something ​ 6个列表，数字分布于60-200之间 ​ 附件4：Bob_try_to_interactive 123456789101112131415161718192021222324252627282930What do you want to get?[1]the pk list[2]Alice Public Parameters[3]Mixed Flag[4]exitSERVER &lt;INPUT&gt;: 1[~]My pk_list is:[1322842566065856798965165348078862357662198978947230709254526492285633103717144968735233037057635982712449886088094071707373492828329816403406086925271118810344041229312732672575513454776879004607034599714440192959516462346178676822793054022355340273220895758465252657627533580580661259224576036836899300361602939684184409146605413303645375209063407283788834371731645965734210815674655141937633174952825964571184358064898432155429127042537390331662523018090768538304757528325737029530914511997095609887140188315159519726941243145154982311426980770893222512421681100895613703769217217726796485797389777578427706351431, 1929353920719299187661308157981749306000287810274985728139426214822581195090665401749753846077249277129639243707822757055941082464616169391698813564752296766917445328390119101887079278115873441407801269666064184707573218538829473509387530062976418264787144789530314562024653164934843854581804048249892522951148405452048197467260971792040669602533612092283424644152035305528153991413104737633877324819675765337058593912363038132773480442939092315660329419364524776069424287921244597238072942644562723590311132742006220424699393681291317394377782898447415333917160012108428733209008198177742632631879274165624277481851, 2789011373470240533905631892024296570906678296635752216220081790321204618235380094204993170523863943409640177956225417067840314617943182599260568907798576069406172968452018144820358899764046320473076086697805329140694534284547901328504085789250614483796435793917853203275245694757472744115420469760429645812640609868625658899893385756019985012438222660060690915389700165285949020489881437563281013841781250607647190620114790531723711706881018137164963096418632285359393453886085197112836853795501737185507901528886916379304576807819903178457247637148399648414584715050473645451454849514269920884716122913229594738752, 8944887367617587241442393229883580834740342304462111105224025291430611321546396102859687333969359524930738537937019013829384606176130513825457156561590666892656705555749481830166659743707548225210121902143969013444405319894625585668596912347789701976651629049271616876141532892390115295041834392608002822127929010500807946326595393217920014219030212857645423747224881557529221103453754309642068857884385938458625120451502032936317586320054048545222493315098707459226052260059007544536679036212141093443337050020955677617422530969961597220552901351308324088233175574555360591700985283581991040305739566382858380007428, 4397583564610423253499843461668397587635466857732498334676375533511290617079510457503762044490728238057694987978886639696168812864700076791908544778388891874223240097159332439061591837526459605271437124176402469035387238812282824293798762114991886550968552873900950500579121111075038947153723573424753662964020656383407389945413094698336805849701462154602561757363428980638610186902374298570018733098337050825688853874037287219878049002782016236313417300752658640951783183554558075556909424245130397476445117448915568396749223181152049295802355315026409054042717276851919403986477022829837140433933944675291372701186, 1887024557812390859587427679482183732847546004970185587894674995710637541577988021282086719881808142878304006798878288881586175207328098796364980971344261196626251002434715710053431197448244191714456166010179613555563774449838465354540108151902674835883336359438359335789619289783630973892862795355598386473633599846961468826660481787403864011853875011153240424154600064584435939126646722766878200900632739799123128975043646600429503490785669792258905940031301822731688276652795642091651576954347376088562802150248176635532850763237619932687425335901131629912404948543484891756530792238399773172947496813143007946734]What do you want to get?[1]the pk list[2]Alice Public Parameters[3]Mixed Flag[4]exitSERVER &lt;INPUT&gt;: 2[~]Alice public_parameters is(99432570713451062672092617212319674009128734021066252368974800380230695323011362021233083666801384874016217174138172838324478923078565331451675890131482611143922160917396923797235440250981885284277138989238227045468313350149185634986094994817254420199118748807731778875073713159130977981056629225363484612477, 3968529370264936315920184477746788220647053714090169783299608119529824310904496486702826831189864895901209648545829990235312934722991437418299346170024807755247754432133360178045395401174982549914108473260518839316780908593318455968053014605561504763936320319823824648449367236939727402970530941741756355440144535524693269860226342989569545529027400537822905839372506033736360929447563246349881828685681190426611634101046071883134662542428054340117879442277375242419725749540743809427149381516979587301032095071523792619805416206328411405597400382193217814410409605898798472988157572731575592931542612306878517511455)What do you want to get?[1]the pk list[2]Alice Public Parameters[3]Mixed Flag[4]exitSERVER &lt;INPUT&gt;: 3[~]What you want is the flag![(8629971888291975347213791416269354663615597341449778464247397219745286182369049868780117508051847999960298596024452522313329959950925171599359898743763042054503440417555174526249829160862494674723813461791740628652379407441970707977460111090664195622293993068339178752253267336919360579659595380424128716331274966011720520402081818339785138564100448828785381210446654549751563770054480276370471933784135979318211388960544875452302901572290613486671118837737952929707183938688557203481397969599355299594458247427664016117339384449186175616507581548517338060151198448327302002598499596140923762164185685397703246525017, 2382704819350988648204939926259922012821070196393254466517927977328047779007630655554783102909445420233334603414269830021827909871784463842733412228018177538280291666226870925572366499683051585600821733321248692261413823782180369786281108496129071519528138126973685857158738633931510584076135644438451418512008698435996783365565980823146754387114607644836143562871251037131100844233499210456295742002818248405955542240031209179401171271988182498301048707975128420754563407337516505117424026601497057408173728989963923392569169720608288778589977299331468798591689742966007919372616963939427942973022672206407915356894, 7720313960516556678241507800313698506319294922044337939798672519899373894106710230654330788343477820100945131225868724604111187104961165449671731600123366694979688433519949770849824359157765719319384499326446776281094391789559201066092080637825695308899163795101674215619537911161758825346990604246201908242641998141131720545547223028612859544467335764381503082373878441543065709211578323452814290911656080720587522044520123114130521964539949874597280324605268358583300909472806691738357290060135813749592500883291268752974739510309885861678540543885454291467441449775481576475597779098977264432915191026950037121271), (2382704819350988648204939926259922012821070196393254466517927977328047779007630655554783102909445420233334603414269830021827909871784463842733412228018177538280291666226870925572366499683051585600821733321248692261413823782180369786281108496129071519528138126973685857158738633931510584076135644438451418512008698435996783365565980823146754387114607644836143562871251037131100844233499210456295742002818248405955542240031209179401171271988182498301048707975128420754563407337516505117424026601497057408173728989963923392569169720608288778589977299331468798591689742966007919372616963939427942973022672206407915356894, 2507489313693027727447823694213947097758893725637064080783076417422312360728871796716507607648204050957058352447513001293923638548755061814481143157280185982134248529705643296490203782611775648931232850380043060019259802341855745407723808559404538235550140640847652196525197728216863601181861238447111155134874873220188560494260693812235297043755237290506736697473642464212381153314464150028542768640544348115479388781714169932337684281395098898295048720991373671433770742876559915120975993663066370466552784425304512344074776338296352164911126588429313182901480992761403886230939719560496866577975131579057233980418, 3603233069921949635850852842102780282250188557063111749359701863158964441251898915819927526832514804676814118399988368079794874992149765916759224281185627030856640018562907911112504000563096016700256240666273611941320289178055416603630913077176567643353181182220432293206255187929971213857584642985361915813306867425294385269330460752200900341331665528445829353168856397102607628243111558263291982908278855340763809937944911956507459341371522547886786433534425538866644727624245702953159357318705462680438481025308981427064201053009152196210535434082336140957273740170206132676978454465699712662183230838620576397771), (2507489313693027727447823694213947097758893725637064080783076417422312360728871796716507607648204050957058352447513001293923638548755061814481143157280185982134248529705643296490203782611775648931232850380043060019259802341855745407723808559404538235550140640847652196525197728216863601181861238447111155134874873220188560494260693812235297043755237290506736697473642464212381153314464150028542768640544348115479388781714169932337684281395098898295048720991373671433770742876559915120975993663066370466552784425304512344074776338296352164911126588429313182901480992761403886230939719560496866577975131579057233980418, 7769230445155201113494537348459352387708612203054561299606903286112936921859421067127410781913677713423158049411013804288570673695825855969822168904613465090290306226978616894321879293271162132061470408070909310151619998411378202847228354918571965001390588172776972224778839119169450173333867054090477937647516598663804457249106382500709364775634358601371251459877683379682809903658838902783963786177719437968604142810768329151307435649733153348164028321577077681431486645592176232620214087883116496965071120567845561936056520916949714662519666931982850792755106900551200428113854794154127442081282902169286650571401, 1980172577526976953208467529900525783074696095931646996510173485588725995089661024536807562115058145311072178324244275386472867798089304656532882034354969245827559132434491283213041279414052179349423545284449349791764442814795484489622913236952945004885237471927992708071668392107252909374174486979848725181384806622865162901189364378882337523881706060196311538634436782157680819223656846784628557021576760718204769640388889532408106414067642872013172395542468221843563481648375218787976310106718686529056130227939362903825973551762087339318300140188516130629026785777810412625331595370234139359970280877739798474389), (7769230445155201113494537348459352387708612203054561299606903286112936921859421067127410781913677713423158049411013804288570673695825855969822168904613465090290306226978616894321879293271162132061470408070909310151619998411378202847228354918571965001390588172776972224778839119169450173333867054090477937647516598663804457249106382500709364775634358601371251459877683379682809903658838902783963786177719437968604142810768329151307435649733153348164028321577077681431486645592176232620214087883116496965071120567845561936056520916949714662519666931982850792755106900551200428113854794154127442081282902169286650571401, 1575094877701795854498774908638903522669421051531573312093667127284544685427913301822137233349330103439966188241901781657995508053590393431112660182478894250834736190200611323499178795811947949448699368341885262244922319233898608781419619210833188270769502178623446319852515092097374376230284979030896357428170209276025068117869920819506765819887277035215331513588698837794510471067850530536430462916048677656769292228807520578503908679844209663943585309414158448052732725558692228885890997143173078704774290593538094709155128226553159420350131695351485888673216532336279540226705255688328040783577052756207587006270, 6610352931587720854451143899633952315748731096581247094289941806600249309199110458686226240414159314916443802659936796194501937130258325721955971712271359425220780891458718764787684248492736828049383593460850257630134166697516000923586434837108552164118408207483861356227241654737966362556299121885909952085344055245123817034374630986706235981670472671656419267459375338043531055577663540904728281161038164044605649226826294253565008079171696929526279467128593521303305237010056264278316607644578180995774851856042734859960770608950180509999278132547381198060859308178075010227172861725398283857061313337363575325263), (1575094877701795854498774908638903522669421051531573312093667127284544685427913301822137233349330103439966188241901781657995508053590393431112660182478894250834736190200611323499178795811947949448699368341885262244922319233898608781419619210833188270769502178623446319852515092097374376230284979030896357428170209276025068117869920819506765819887277035215331513588698837794510471067850530536430462916048677656769292228807520578503908679844209663943585309414158448052732725558692228885890997143173078704774290593538094709155128226553159420350131695351485888673216532336279540226705255688328040783577052756207587006270, 2899196346496640651515578300741477267252027393819388234592692441244872565455171075206663782801019182310445822694710022355107834170061256021528233984226982722687848721193571620263169761625920013511824364907813108870230498313614430769087521400686949128276439718637571413546438066894526733998540267545169908267918034044567676900418717621781005337988884902642672158843440942895072083594499934345701806316446232804191200045145796718350218780127702500537329430739697477802056514649362531623994574050100569446437453774196354144878113348032018382822752357224093912706852592549799275481078987386652273745516181324786938308335, 1518486070937095431267728249967625462615084214873519869724691145931391888893984408735020316869577560635376392428533320137999061224646280418013600820687411977047143852240859128701565827810521684321783327786465208897593862389568908868890826199105669712761247928108093008056596587483514169117862021972656609656939975812867444210967581049993172306174305541579882729780098039933312778734112663231561634590403753870449301486897270821771001471591549309582677751258104686430351246789904546466436576979978832001105662418364938101412232320509104886209874169009281768978468363614092630860981345300448240861393056424955085865425)]What do you want to get?[1]the pk list[2]Alice Public Parameters[3]Mixed Flag[4]exitSERVER &lt;INPUT&gt;: 4 ​ 考察知识点：快速幂算法、侧信道攻击、同态加解密 ​ 思路：题目给了hint“快速幂的消耗”。而密码系统生成公私钥，是通过模幂运算（幂为私钥）进行，并且附件三刚好六个列表，和生成Bob请求6对公私钥相对应。猜测系统使用的是快速幂算法来生成公私钥，附件三则是快速幂算法计算时消耗的能量，这里类似于侧信道攻击，先要了解快速幂算法。 12345678def fastpower(a,b,n): ans = 1 while n: if n&amp;1: ans = ans*a%b a = a*a%b n &gt;&gt;= 1 return ans%b ​ 从快速幂算法可以看出，如果幂的某一位是0，则运算步骤更少（消耗的能量少），为1则运算步骤更多。因此，基本可以确定，附件三为快速幂运算时消耗的能量，那么可以通过侧信道攻击来恢复私钥。要恢复私钥，需要确定能量消耗高低的阈值，可以通过找到最高值和最低值的中间值，在中间值附近爆破确定阈值。 ​ 私钥可以搞定，下一步就用私钥同态解密即可。推导过程： ​ exp： 123456789101112131415161718192021222324252627282930313233343536from Crypto.Util.number import *import gmpy2def other_decrypt(A1,A2,B,sk1,sk2,tmpm): tmp = (gmpy2.invert(pow(A1,sk1,n*n),n*n) * inverse(pow(A2,sk2,n*n),n*n) * inverse( 1+ tmpm * n, n*n )) % (n * n) B = B * tmp % (n*n) c = (B - 1) // n return csk_power = [[]]pk_list = []n,g = (99432570713451062672092617212319674009128734021066252368974800380230695323011362021233083666801384874016217174138172838324478923078565331451675890131482611143922160917396923797235440250981885284277138989238227045468313350149185634986094994817254420199118748807731778875073713159130977981056629225363484612477, 3968529370264936315920184477746788220647053714090169783299608119529824310904496486702826831189864895901209648545829990235312934722991437418299346170024807755247754432133360178045395401174982549914108473260518839316780908593318455968053014605561504763936320319823824648449367236939727402970530941741756355440144535524693269860226342989569545529027400537822905839372506033736360929447563246349881828685681190426611634101046071883134662542428054340117879442277375242419725749540743809427149381516979587301032095071523792619805416206328411405597400382193217814410409605898798472988157572731575592931542612306878517511455)sk_ = []for i in range(len(sk_power)): sk = &#x27;&#x27; for j in range(len(sk_power[i])): if sk_power[i][j] &gt;= 120: #这里类似于测信道攻击，需要多次尝试确定阈值 sk += &#x27;1&#x27; else: sk += &#x27;0&#x27; sk = int(sk,2) s = (pow(g,sk,n*n)) assert(int(s) == pk_list[i]) sk_.append(sk)print(sk_)if __name__ == &#x27;__main__&#x27;: c_list = [] tmpm = bytes_to_long(b&#x27;vnctf&#x27;) print(long_to_bytes(tmpm).decode(), end=&#x27;&#x27;) for i in range(5): newm = (other_decrypt(c_list[i][0], c_list[i][1], c_list[i][2], sk_[i], sk_[(i + 1)], tmpm)) print(long_to_bytes(newm).decode(), end=&#x27;&#x27;) tmpm = newm","categories":[{"name":"赛事","slug":"赛事","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/"},{"name":"VNCTF2022","slug":"赛事/VNCTF2022","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/VNCTF2022/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"赛事","slug":"赛事","permalink":"http://example.com/tags/%E8%B5%9B%E4%BA%8B/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"},{"name":"misc","slug":"misc","permalink":"http://example.com/tags/misc/"}]},{"title":"Docker学习","slug":"Docker学习","date":"2022-02-10T02:26:13.000Z","updated":"2022-02-12T15:10:51.941Z","comments":true,"path":"2022/02/10/Docker学习/","link":"","permalink":"http://example.com/2022/02/10/Docker%E5%AD%A6%E4%B9%A0/","excerpt":"一.认识Docker​ 知乎的这个问题下面的回答讲的很清楚，尤其是木龙头师傅的回答，将操作系统、虚拟机以及容器串联起来解析，从宏观和微观两个角度认识Docker：https://www.zhihu.com/question/28300645 ​ 我觉得认识镜像和容器的关系非常重要，请参考这篇文章：https://blog.csdn.net/qq_40722827/article/details/102827125","text":"一.认识Docker​ 知乎的这个问题下面的回答讲的很清楚，尤其是木龙头师傅的回答，将操作系统、虚拟机以及容器串联起来解析，从宏观和微观两个角度认识Docker：https://www.zhihu.com/question/28300645 ​ 我觉得认识镜像和容器的关系非常重要，请参考这篇文章：https://blog.csdn.net/qq_40722827/article/details/102827125 二.Docker基本命令及作用1.Docker容器使用​ 注：由于解析器的原因，本篇中双短横线显示为一根较长横线 ​ （1）客户端直接输入docker可以查看docker客户端的所有命令选项，而docker command —help可以查看某个命令的具体参数 ​ （2）docker pull … 本地没有所需镜像的时候可以从仓库拉取镜像，如docker pull ubuntu ​ （3）启动容器 docker run [OPTIONS] IMAGE [COMMAND] [ARG…] 参数解析： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； —name=”nginx-lb”: 为容器指定一个名称； —dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； —dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； —env-file=[]: 从指定文件读入环境变量； —cpuset=”0-2” or —cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； —net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； —link=[]: 添加链接到另一个容器； —expose=[]: 开放一个端口或一组端口； —volume , -v: 绑定一个卷 ​ 举例：使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。 1docker run --name mynginx -d nginx:latest ​ 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。 1docker run -P -d nginx:latest ​ 使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。 12docker run -p 80:80 -v /data:/data -d nginx:latest # :后边跟上版本号#如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。 ​ 以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器： 1docker run -it ubuntu /bin/bash #exit直接退出shell ​ （4）启动已停止的容器 ​ 先查看有哪些容器： 1docker ps -a #去掉-a则只会显示正在运行的容器 ​ 然后启动某个特定容器： 12docker start b750bbbcfd88 docker stop ... #这是停止容器 ​ （5）后台运行容器 （加了 -d 参数默认不会进入容器，想要进入容器需要使用指令 docker exec） 1docker run -itd --name ubuntu-test ubuntu /bin/bash ​ 进入容器： 1docker attach 1e560fca3906 ​ 更推荐使用docker exec，当我们退出容器shell的时候容器还会继续在后台运行，不会结束： 1docker exec -it 243c32535da7 /bin/bash ​ 导出和导入容器 ​ 导出： 1docker export 1e560fca3906 &gt; ubuntu.tar ​ 可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1： 注：| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l 1cat docker/ubuntu.tar | docker import - test/ubuntu:v1 1docker import my_ubuntu_v3.tar runoob/ubuntu:v4 #方法二 更简单 ​ （6）删除容器 用docker rm + id 要先停止容器才能删除，否则会报错，加上-f指令则会强制删除正在运行的容器 ​ （7）docker top + id 可以查看某个容器内部运行的进程 ​ （8）使用 docker inspect 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息 2.Docker镜像使用​ （1）docker image列出本地镜像 ​ （2）查找搜索镜像可以用docker search … ​ （3）docker rmi hello-world （删除名为hello-world的镜像） ​ （4）创建镜像 ​ 镜像不满足使用的需求时，有两种处理手段： ​ a.更新镜像 ​ 更新之前，需要用docker run 创建并进入交互shell，在运行的容器内使用apt-get update命令更新，完成以后输入exit退出容器的shell。然后可以通过命令 docker commit 来提交更改的容器副本：也就是将容器存为镜像。 123runoob@runoob:~$ docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2sha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8#m为详细信息，a为作者，runoob/ubuntu:v2为镜像名 ​ b.构建镜像","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://example.com/categories/Docker%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"区块链—第一课—认识区块链","slug":"区块链—第一课—认识区块链","date":"2022-02-09T14:05:30.000Z","updated":"2022-02-09T15:34:26.356Z","comments":true,"path":"2022/02/09/区块链—第一课—认识区块链/","link":"","permalink":"http://example.com/2022/02/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E2%80%94%E7%AC%AC%E4%B8%80%E8%AF%BE%E2%80%94%E8%AE%A4%E8%AF%86%E5%8C%BA%E5%9D%97%E9%93%BE/","excerpt":"中本聪和比特币​ 中本聪，一个可以被称之为天才的人物，其创造的比特币（货币系统）带来了区块链，而区块链技术可能带来互联网的二次革命，把互联网从“信息互联网”带向“价值互联网”。举个例子，如果说比特币是面条，那么区块链就是面粉，后面大家发现面粉除了能做面条还可以做馒头跟包子。","text":"中本聪和比特币​ 中本聪，一个可以被称之为天才的人物，其创造的比特币（货币系统）带来了区块链，而区块链技术可能带来互联网的二次革命，把互联网从“信息互联网”带向“价值互联网”。举个例子，如果说比特币是面条，那么区块链就是面粉，后面大家发现面粉除了能做面条还可以做馒头跟包子。 ​ 在比特币的创世时刻，它的三个组成部分都出现了，即加密数字货币（cryptocurrency）、分布式账本（distributed ledger）、去中心网络（decentralized network），如下图所示。 ​ 比特币常被称为一种“加密数字货币”，人们常很关注其中的“货币”二字。其实，比特币并不具备现在各国法定货币的特征，它只是一种数字形式的特殊商品。 ​ 比特币的出现是源于技术极客想解决的一个技术难题：“在数字世界中，如何创造一种具有现金特性的事物？” “比特币：一个点对点电子现金系统”这个标题体现出了中本聪想解决的难题：他想创造在数字世界中可用的电子现金，它可以点对点也就是个人对个人交易，交易中不需要任何中介参与。来对比看看。在物理世界中，一个人可以把现金纸币给另一个人，不需要经过诸如银行、支付机构、见证人等中介机构。但由于数字文件是可复制的，复制出来的电子文件是一模一样的，因而在数字世界中，我们不能简单地用一个数字文件作为代表价值的事物。同时，我们在支付机构中有多少钱，并没有像一张张钞票一样的数字文件可以代表，钱仅是中心化数据库中的记录。在数字世界中，当一个人要把现金转给另一个人时，必须要有中介机构的参与。比如，我们通过支付宝转账的过程是：支付宝在一个人的账户记录里减掉一定金额，在另一个人的账户记录中增加一定金额。在数字世界中，如何创建一个无须中介或者说去中心化的数字现金，一直是一个难题。由于数字文件可以完美复制，如果没有一个中心化数据库做记录，那如何避免一个人把一笔钱花两次？这就是所谓的双重支付或双花问题（double spending）。在比特币出现之前，我们熟悉的主要电子现金系统（如PayPal、支付宝等）都是依靠中心化数据库来避免双花问题，这些可信第三方中介不可或缺，见下图。 ​ 到了 2008 年，中本聪借鉴和综合前人的成果，特别是现在常被统称为密码朋克（cypherpunk）的群体的成果，改进之前各类中心化和去中心化的电子现金，加上自己的独特创新，创造了比特币这个点对点电子现金系统，在无须中介的情况下解决了双花问题。 ​ 特别地，比特币这个电子现金系统是同时去中介化和去中心化的： 个人与个人之间的电子现金无须可信第三方中介的介入，这是去中介化。 这个电子现金的货币发行也不需要一个中心化机构，而是由代码与社区共识完成，这是去中心化。 ​ 要注意的是，这个“电子现金”中的现金指的并非货币，它只是在解决难题的过程中被借用来在数字世界中代表价值的说法。这样说是为了便于理解，在现实中，最常见的代表价值的事物是现金。 从比特币系统发现区块链​ 在物理世界中，现金是一张张纸币，但其背后有着一整套与货币相关的金融体系：中央银行、银行、印钞厂、信用卡组织，以及后来出现的第三方网络支付机构等。 ​ 在数字世界中，想要创造一种去中介化、去中心化的“电子现金”，同样要设计一套完整的系统。这一系统要能解决以下一系列问题： 这种“现金”如何公平、公正地发行出来，不被任何中心化的机构或个人控制？ 如何实现像在物理世界中一样，一个人可以直接把现金递给另一个人，无须任何中介的协助？（现在的网银、微信支付宝实际上是通过中介交易的） 这种电子现金如何“防伪”？在数字世界中，这个问题可转换为，一笔电子现金如何不被花费两次？ ​ 中本聪设计和开发了比特币系统，完美地解决了这些问题。说起比特币，人们常指的是比特币这种做价值表示的电子现金。其实，作为电子现金的比特币只是比特币系统的表层，比特币系统包括三层： 最上一层是比特币这种电子现金。这是整个系统的应用层。（个人理解为与经济学相关的价值体系，类似于某种货币形式） 中间一层的功能是发行比特币与处理用户间的比特币转移。这一层也叫比特币协议（bitcoin protocol），是整个系统的应用协议层。（与上层“货币”对接，跟上层的特性有关，主要就是货币发行和转移） 最底层是比特币的分布式账本和去中心网络。这一层也被称为比特币区块链（bitcoin blockchain），是整个系统的通用协议层。（简单来说，就是比较通用的一系列协议，可以用于各种去中心化的“价值互联网”） ​ 比特币系统的三层命名（应用层、应用协议层、通用协议层）源自知名区块链研究者梅兰妮·斯万，她也提出了被广泛引述的一种阶段划分：区块链 1.0 是货币、区块链 2.0 是合约、区块链 3.0是应用。 ​ 比特币系统实现的去中心化的点对点电子现金，其发行与转账靠的是中间的比特币协议层。类比现实货币系统，这一层的角色相当于中央银行（发行货币）与银行（处理转账）等金融机构。 ​ 深入介绍“比特币协议”的这一层。比特币系统架构图又常被进一步细分为五层，它对应的是比特币协议和比特币区块链两个部分。在这个五层架构中，比特币协议层被细分为：应用层、激励层和共识层。 ​ 在设计比特币系统时，中本聪创造性地把计算机算力竞争和经济激励相结合（我认为，相较于去中心化，中本聪把真实世界的市场经济因素与计算机的特点相互映射，才是更具创造性的地方），形成了工作量证明（proof-of-work，POW）共识机制，让挖矿计算机节点在计算竞争中完成了货币发行和记账功能，也完成了区块链账本和去中心网络的运维。这就形成了一个完整的循环：矿机挖矿（算力竞争），完成去中心化记账（运转系统），获得比特币形式的经济激励（经济奖励）。 ​ 比特币的工作量证明共识机制是承上启下的一层，连接了上层应用与下层技术：在其上的层次为电子现金的发行、转账、防伪；在其下的层次，去中心网络的节点达成一致，更新分布式账本。 区块链的定义第一种区块链的定义（比较通俗）​ 比特币：一种加密数字货币；区块链：一种基础技术。 ​ 区块链是一种源自于“比特币”的底层技术。换句话说，比特币是区块链技术的第一个大获成功的应用。 第二种区块链的定义​ 区块链是数字世界中进行“价值表示”和“价值转移”的技术。区块链 一面是表示价值的加密数字货币或通证，另一面是进行价值转移的分布式账本与去中心网络（即经济学与计算机网络的结合）。 ​ 分布式账本与去中心网络也常被称为“链”，它可被视为一个软件平台；而表示价值的通证常被称为“币”。 通证存储在链上，通过链上的代码（主要形式的智能合约）来管理，它是可编程的。 ​ 现在，很多人都有一种看法是，将基于区块链的价值表示物都称为通证，并把比特币等代币（coin）视为通证的一个特定种类。通常而言，提及加密数字货币、通证、代币时，我们指的都是基于区块链的、在数字世界中进行价值表示的事物。如果采用“通证”说法，区块链的最大范围包括的则是“账本+网络+协议+通证”（即一个完整系统）。","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://example.com/categories/Blockchain/"},{"name":"基础知识","slug":"Blockchain/基础知识","permalink":"http://example.com/categories/Blockchain/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://example.com/tags/Blockchain/"}]},{"title":"HGAME-2022","slug":"HGAME-2022","date":"2022-02-09T04:48:55.000Z","updated":"2022-02-11T02:29:46.989Z","comments":true,"path":"2022/02/09/HGAME-2022/","link":"","permalink":"http://example.com/2022/02/09/HGAME-2022/","excerpt":"​ 主要记录2022年hgame密码方向的题目wp（脑洞题未记录），也有一点点misc（实际上目前misc是ak了的，比较简单就不记录了）。","text":"​ 主要记录2022年hgame密码方向的题目wp（脑洞题未记录），也有一点点misc（实际上目前misc是ak了的，比较简单就不记录了）。 大概的最终Rank：47/1200 ​ Week1Dancing Line​ 这题出的比较新颖，将ASCII码值放在bmp的像素信息中。一个字符的 ASCII码有 8 位，图像中的每两个黑色色块间的路程也为 8 步。从左上角的色块出发，向右为 0，向下为 1，连起来就是对应字符的 ASCII 码。做题的时候我直接人工对应的ascii码，比较麻烦，可以用脚本梭： 123456789101112131415161718192021222324252627import numpy as npfrom PIL import Image# 判断下一步往哪走def search(arr, x, y): if y + 1 &lt; arr.shape[1] and (arr[x, y + 1, :] != 255).all(): #(255,255,255)表示白色 (0,0,0)表示黑色 return x, y + 1, 0 elif x + 1 &lt; arr.shape[0]: return x + 1, y, 1 else:return -1, -1, -1if __name__ == &quot;__main__&quot;: image = Image.open(&quot;Dancing Line.bmp&quot;) array = np.array(image) print(array.shape[1]) x = y = 0 while True: asc = 0 # 每八步拼接成一个字符的 ASCII 码 for _ in range(8): x, y, v = search(array, x, y) if v &lt; 0: exit() asc &lt;&lt;= 1 asc |= v print(chr(asc), end = &quot;&quot;) #hgame&#123;Danc1ng_L1ne_15_fun,_15n&#x27;t_1t?&#125; English Novel​ 已知明文攻击。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import osdef if_length(ori_content, enc_content, match_result): if len(ori_content) == len(enc_content): match_result = True else: match_result = False return match_resultdef if_match(ori_name, enc_name): match_result = True ori_path = ori_folder + &#x27;/&#x27; + ori_name enc_path = enc_folder + &#x27;/&#x27; + enc_name with open(ori_path, &#x27;r&#x27;) as f: ori_content = f.read() with open(enc_path, &#x27;r&#x27;) as f: enc_content = f.read() match_result = True if match_result: match_result = if_length(ori_content, enc_content, match_result) if match_result: for i in range(len(ori_content)): if ori_content[i] == enc_content[i]: continue elif ori_content[i].isupper() and enc_content[i].isupper(): continue elif ori_content[i].islower() and enc_content[i].islower(): continue else: match_result = False return match_resultdef match_process(ori_folder, enc_folder): all_match = [] original_list = os.listdir(ori_folder) encrypt_list = os.listdir(enc_folder) for ori_name in original_list: for enc_name in encrypt_list: match_result = if_match(ori_name, enc_name) if match_result: ori_path = ori_folder + &#x27;/&#x27; + ori_name enc_path = enc_folder + &#x27;/&#x27; + enc_name match_group = [ori_path, enc_path] all_match.append(match_group) encrypt_list.remove(enc_name) else: continue return all_matchdef decrypt(ori_data, enc_data, enc_flag): keys = [] for i in range(len(enc_data)): key = ord(enc_data[i]) - ord(ori_data[i]) keys.append(key) result = &quot;&quot; enc_data = enc_flag for i in range(len(enc_data)): if enc_data[i].isupper(): result += chr((ord(enc_data[i]) - ord(&#x27;A&#x27;) - keys[i]) % 26 + ord(&#x27;A&#x27;)) elif enc_data[i].islower(): result += chr((ord(enc_data[i]) - ord(&#x27;a&#x27;) - keys[i]) % 26 + ord(&#x27;a&#x27;)) else: result += enc_data[i] return resultif __name__ == &#x27;__main__&#x27;: ori_folder = &#x27;./original&#x27; enc_folder = &#x27;./encrypt&#x27; enc_flag = open(&#x27;./flag.enc&#x27;, &#x27;r&#x27;).read() match_list = match_process(ori_folder, enc_folder) for match_group in match_list: with open(match_group[0], &#x27;r&#x27;) as f: ori_data = f.read() with open(match_group[1], &#x27;r&#x27;) as f: enc_data = f.read() flag = decrypt(ori_data, enc_data, enc_flag) print(&quot;&#123;:&lt;30&#125;&#123;:&lt;30&#125;&#123;:&lt;30&#125;&quot;.format(match_group[0], match_group[1], flag)) week2The Password Plus Pro Max Ultra​ ​ exp： 1234567891011121314151617181920212223242526272829from functools import reducefrom operator import xorfrom libnum import n2sdef move(n, k): s = bin(n)[2:].zfill(64) k &amp;= 63 return int(s[k:] + s[:k], 2)def encrypt(x, ks): return xor(x, reduce(xor, map(lambda k: move(x, k), ks)))def decrypt(y, ks): for _ in range(6): y = encrypt(y, ks) ks = [k &lt;&lt; 1 for k in ks] return yif __name__ == &quot;__main__&quot;: ys = [2656224875120172108,1261711348908201279,18219282869614004824,15279054981769814589,7966355346882200701,5641592208539483808,1502927090219059154,3996223120734273799,18295033054788808618,18126228466291248047,9413762634844369954,8964324149921197550,6962485320551449848] kss = ([8, 35],[19, 29, 30, 45],[6, 16, 18, 21, 44, 55],[10, 26, 30, 46, 51, 54, 58, 63],[5, 13, 25, 29, 37, 39, 43, 52, 53, 59],[1, 26, 31, 39, 40, 41, 43, 45, 49, 52, 54, 62], [8, 12, 19, 20, 30, 32, 34, 40, 41, 45, 46, 49, 55, 58],[2, 3, 5, 6, 8, 10, 15, 19, 26, 27, 33, 40, 42, 47, 52, 61],[1, 16, 17, 27, 28, 30, 32, 36, 37, 38, 39, 48, 49, 51, 55, 57, 59, 62], [5, 11, 12, 20, 22, 23, 25, 27, 31, 32, 33, 37, 44, 45, 49, 52, 53, 59, 61, 62],[2, 7, 10, 12, 18, 19, 20, 22, 26, 29, 33, 34, 38, 40, 41, 45, 46, 51, 54, 56, 57, 60], [3, 4, 5, 9, 12, 13, 18, 19, 21, 23, 24, 25, 30, 33, 34, 35, 37, 39, 43, 44, 46, 49, 50, 53],[1, 3, 6, 7, 10, 11, 13, 14, 23, 27, 32, 33, 35, 37, 39, 41, 46, 48, 49, 50, 51, 53, 54, 56, 58, 62]) flag =&#x27;&#x27; for i in ys: flag = flag + str(n2s(decrypt(i,kss[ys.index(i)])))[2:10] print(flag) #hgame&#123;XOr|RoR&amp;rOl|Is+vERY#coMmon*BiTwisE$OPeraTiOn*IT@is%oFten,ENCOUntErED*in.syMMeTRic?encryPtION&#125; 奇妙小游戏（misc）​ nc连接，会收到一段sha256散列值，需要输入其哈希之前的原始值，长度为4位，所以这里可以爆破，输入正确以后游戏开始，如下图；反复输入不同结果发现其逻辑为鬼脚图，我的exp写的比较复杂。 ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102# -*- coding:utf-8 -*-from pwn import *import numpy as npdef jm_sha256_single(value): &quot;&quot;&quot; sha256加密 :param value: 加密字符串 :return: 加密结果转换为16进制字符串 &quot;&quot;&quot; hsobj = hashlib.sha256() hsobj.update(value.encode(&quot;utf-8&quot;)) return hsobj.hexdigest().lower()#爆破哈希def hashs(hashs): chart1 = list(range(65, 123)) chart2 = list(range(48, 57)) chart1.extend(chart2) for i1 in chart1: for i2 in chart1 : for i3 in chart1: for i4 in chart1: s = chr(i1)+chr(i2)+chr(i3)+chr(i4) if jm_sha256_single(s) == hashs: print(s) io.sendline(s.encode()) io.sendline(s.encode()) return 0def short(row,col,msg,have_gone,max): #have_gone是一个列表，用来存储走过的节点 have_gone.append((row,col)) if msg[row,col-1] != &quot; &quot; and col-1 &gt;= 0 and (row,col-5) not in have_gone: col = col - 5 print(row,col) print(have_gone) return short(row,col,msg,have_gone,max) elif col+5 &lt; max and msg[row,col+1] != &quot; &quot; and col &gt;= 0 and (row,col+5) not in have_gone : col = col +5 print(row,col) print(have_gone) return short(row,col,msg,have_gone,max) else: row = row - 1 print(row,col) print(have_gone) if row == 0: return col//5 else: return short(row,col,msg,have_gone,max)if __name__ == &#x27;__main__&#x27;: io = remote(&#x27;chuj.top&#x27;,51009) hello = str(io.recvuntil(&quot;&gt;&quot;.encode())) start = hello.find(&#x27;) =&#x27;) hashstr = hello[start+5:start+69] print(hashstr) hashs(hashstr) for i in range(15): p = str(io.recvuntil(b&quot;answer&quot;)) if p : print(p) num_start = p.find(&#x27;is&#x27;)+3 recv_num = p[num_start] col = p.count(&quot;-&quot;) //3 print(col) start1 = p.find(&#x27;level&#x27;) + col + 11 p = p[start1:] tail1 = p.find(&#x27;-&#x27;) p = p[:tail1] row = p.count(&#x27;\\\\&#x27;) # col = (len(p) - row*2)//row p = p.replace(&quot;\\\\n&quot;,&#x27;&#x27;) p = &quot;0&quot;*col + p msg = np.array(list(p)).reshape(row+1,col) print(msg) print(p) print(row,col) print(recv_num) enter_col = int(recv_num) * 5 maxcol = col #start_point = msg[row-1,enter_col] have_gone = [] d=short(row,enter_col,msg,have_gone,maxcol) io.sendline(str(d).encode()) print(d) else: print(&quot;no answer&quot;) p = str(io.recvrepeat(timeout=5)) print(p) week3Block Cipher1234567891011121314151617181920212223242526272829303132333435import operatorimport randomimport refrom functools import reducedef pad(s): padding_length = (8 - len(s)) % 8 return s + chr(padding_length) * padding_lengthdef xor(a, b): assert len(a) == len(b) return bytes(map(operator.xor, a, b))def encrypt(s): iv = bytes(random.randint(0, 255) for _ in range(8)) #生成8字节的字节流（字符串） key = bytes(random.randint(0, 255) for _ in range(8)) #同上 parts = list(map(str.encode, map(pad, re.findall(r&#x27;.&#123;1,8&#125;&#x27;, s)))) #进行填充 results = [] for index, part in enumerate(parts): results.append(reduce(xor, [part, iv if index == 0 else results[-1], key]))iv = b&#x27;Up\\x14\\x98r\\x14%\\xb9&#x27;key = b&#x27;\\r\\xe8\\xb86\\x9c33^&#x27;parts = [b&#x27;0\\xff\\xcd\\xc3\\x8b\\\\T\\x8b&#x27;, b&#x27;RT\\x1e\\x89t&amp;\\x17\\xbd&#x27;, b&#x27;\\x1a\\xee\\x8d\\xd6\\x9b&gt;w\\x8c&#x27;, b&#x27;9CT\\xb3^pF\\xd0&#x27;]flag1 = reduce(xor,[parts[0],key,iv])print(flag1)flag2 = reduce(xor,[parts[1],iv,flag1])print(flag2)flag3 = reduce(xor,[parts[2],parts[0],flag2])print(flag3)flag4 = reduce(xor,[parts[3],parts[1],flag3])print(flag4)print(flag1+flag2+flag3+flag4)#hgame&#123;BloCk|cIphER+is+So.EaSY&#125; Multi Prime RSA123456789101112131415from Crypto.Util.number import *import gmpy2#多因数rsa就用欧拉函数计算phi即可p = 109056753224725357860050862987465749131702509174531265860789564184166504627089q = 64871884070495743485110397060920534297122908609816622599229579748089451488127r = 73817195552029165561107245309535744382442021553254903166961729774806232509583s = 89907870347457693114161779597928900080173728317019344960807644151097370118553n = 337945247991531188630780631650822497552908401425959508214145019590891175999570651678385514599227649321033438265588883204645721459926338248032512615537333971869461679586403649697114789385472197685140603238299768873935137939123021910982793481655218061907401584383081422244812725080939394854989735528833013780919908024635812696998644603525843637686545709789908672408993923182946718279531020289767042649725545073526307769817097790005360720650079676982379162926484355121626302801800589993422729725583400678081766553017405965706770238634252836827793877622715474210575752508172785712202444441372140501379422725172250199713113954442223362073485143579617841236442644760494913432967541691532709842303408702693199269606594116690052170245340072114122287646793344327315326489574192325790848798131621842606487734721409882742631176999703502149639410263361145441889337623403361569958342141903891414217371443118527025041591219747780100510414268546884029077010164415049298406632069845430841542680166802473749172801804659277821899576403669845353379213803866969800665351300325701817179936198902427032684058452719607840314873315299975603264092020097224735237221994922702705781103002327285724125001893421030923788361576161461965707958695720464547129911053732747399113017747456439027947305796290572816318795181398935020951025833913e = 65537c = 281020926647419736778465777714512241989738235339105762863874725870511725155101862585192241287617168165290485944476735304459717602798728005687755713662466866091315959960168862035396245078850168822145228676116894754613436735897122137945552880864031115366493898382809812977280234389519365119627504653135151731589924405933589175425427189436855517194951589952822691774400942764910734054237756669945324833759799471068481769516338068810710333940167779043544371586185132920304774984746129764220081092726473696111126293966890901487735046101991609292612206984184161394385767762455321150541601949740631911175736268756408775307673610842645555513631617648877296855194327486811545670357137463942744122553468603244298691801028147147418563982169678640270746871085722092365159546820433098926679284504740402248142173715649451061037156261913601096905601577932894877435316535261789072594174871292814951406337447799051502635390866434813419165738873787323716033378045850292413169255965421404580559241351577058726176436504950558398769061998430771982995850759810867299728407860522399699076192754977454139708618158667289120827143703464056583125568576691058753072898162981956883451252542611323974071518397220203389962420073122776649094369816178685947397943358134020598211306649724455966463885765977564934172273334309312046278116760547phi = p*(p-1)*(q-1)*q**2*(r-1)*r**4*(s-1)*s**6d = gmpy2.invert(e,phi)print(long_to_bytes(pow(c,d,n)))#hgame&#123;EulEr:fUNcTIon;iS.So*IMpORTaNt*In&amp;RsA&#125; RSA Attack 3123456789import gmpy2from Crypto.Util.number import *d = 13094612077654083919 #维纳攻击先求dn = 507419170088344932990702256911694788408493968749527614421614568612944144764889717229444020813658893362983714454159980719026366361318789415279417172858536381938870379267670180128174798344744371725609827872339512302232610590888649555446972990419313445687852636305518801236132032618350847705234643521557851434711389664130274468354405273873218264222293858509477860634889001898462547712800153111774564939279190835857445378261920532206352364005840238252284065587291779196975457288580812526597185332036342330147250312262816994625317482869849388424397437470502449815132000588425028055964432298176942124697105509057090546600330760364385753313923003549670107599757996810939165300581847068233156887269181096893089415302163770884312255957584660964506028002922164767453287973102961910781312351686488047510932997937700597992705557881172640175117476017503918294534205898046483981707558521558992058512940087192655700351675718815723840568640509355338482631416345193176708501897458649841539192993142790402734898948352382350766125000186026261167277014748183012844440603384989647664190074853086693408529737767147592432979469020671772152652865219092597717869942730499507426269170189547020660681363276871874469322437194397171763927907099922324375991793759e = 77310199867448677782081572109343472783781135641712597643597122591443011229091533516758925238949755491395489408922437493670252550920826641442189683907973926843505436730014899918587477913032286153545247063493885982941194996251799882984145155733050069564485120660716110828110738784644223519725613280140006783618393995138076030616463398284819550627612102010214315235269945251741407899692274978642663650687157736417831290404871181902463904311095448368498432147292938825418930527188720696497596867575843476810225152659244529481480993843168383016583068747733118703000287423374094051895724494193455175131120243097065270804457787026492578916584536863548445813916819417857064037664101684455000184987531252344582899589746272173970083733130106407810619258077266603898529285634495710846838011858287024329514491058790557305041389614650730267774482954666726949886313386881066593946789460028399523245777171320319444673551268379126203862576627540177888290265714418064334752499940587750374552330008143708562065940245637685833371348603338834447212248648869514585047871442060412622164276894766238383894693759347590977926306581080390685360615407766600573527565016914830132066428454738135380178959590692145577418811677639050929791996313180297924833690095c = 165251729917394529793163344300848992394021337429474789711805041655116845722480301677817165053253655027459227404782607373107477419083333844871948673626672704233977397989843349633720167495862807995411682262559392496273163155214888276398332204954185252030616473235814999366132031184631541209554169938146205402400412307638567132128690379079483633171535375278689326189057930259534983374296873110199636558962144635514392282351103900375366360933088605794654279480277782805401749872568584335215630740265944133347038070337891035560658434763924576508969938866566235926587685108811154229747423410476421860059769485356567301897413767088823807510568561254627099309752215808220067495561412081320541540679503218232020279947159175547517811501280846596226165148013762293861131544331444165070186672186027410082671602892508739473724143698396105392623164025712124329254933353509384748403154342322725203183050328143736631333990445537119855865348221215277608372952942702104088940952142851523651639574409075484106857403651453121036577767672430612728022444370874223001778580387635197325043524719396707713385963432915855227152371800527536048555551237729690663544828830627192867570345853910196397851763591543484023134551876591248557980182981967782409054277224print(long_to_bytes(pow(c,d,n)))#hgame&#123;dO|YOU:kNOw!tHE*PRINcIplE*bEhInd%WInNEr#aTTacK&#125;&#x27;","categories":[{"name":"赛事","slug":"赛事","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/"},{"name":"HGAME2022","slug":"赛事/HGAME2022","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/HGAME2022/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"赛事","slug":"赛事","permalink":"http://example.com/tags/%E8%B5%9B%E4%BA%8B/"},{"name":"misc","slug":"misc","permalink":"http://example.com/tags/misc/"}]},{"title":"CTFshow-1024杯","slug":"CTFshow-1024杯","date":"2022-02-03T04:41:52.000Z","updated":"2022-02-03T05:27:08.010Z","comments":true,"path":"2022/02/03/CTFshow-1024杯/","link":"","permalink":"http://example.com/2022/02/03/CTFshow-1024%E6%9D%AF/","excerpt":"1024_Trick1234567891011121314151617181920212223242526from Crypto.Util.number import getPrime, bytes_to_longfrom gmpy2 import gcd, invertfrom secret import flagdef gen(x, y): while True: k = getPrime(1024) if gcd(x * y - x - y + 1, k) == 1 and gcd(x * y - x - y + 1, k + 1024) == 1: return kp = getPrime(1024)q = getPrime(1024)d = gen(p, q)e1 = invert(d, (p - 1) * (q - 1))e2 = invert(d + 1024, (p - 1) * (q - 1))n = p * qc = pow(flag, e1, n)out = open(&#x27;output&#x27;, &#x27;w&#x27;)out.write(str(n)+&#x27;\\n&#x27;)out.write(str(e1)+&#x27;\\n&#x27;)out.write(str(e2)+&#x27;\\n&#x27;)out.write(str(c)+&#x27;\\n&#x27;)","text":"1024_Trick1234567891011121314151617181920212223242526from Crypto.Util.number import getPrime, bytes_to_longfrom gmpy2 import gcd, invertfrom secret import flagdef gen(x, y): while True: k = getPrime(1024) if gcd(x * y - x - y + 1, k) == 1 and gcd(x * y - x - y + 1, k + 1024) == 1: return kp = getPrime(1024)q = getPrime(1024)d = gen(p, q)e1 = invert(d, (p - 1) * (q - 1))e2 = invert(d + 1024, (p - 1) * (q - 1))n = p * qc = pow(flag, e1, n)out = open(&#x27;output&#x27;, &#x27;w&#x27;)out.write(str(n)+&#x27;\\n&#x27;)out.write(str(e1)+&#x27;\\n&#x27;)out.write(str(e2)+&#x27;\\n&#x27;)out.write(str(c)+&#x27;\\n&#x27;) ​ 分析： ​ exp： 12345678910111213from Crypto.Util.number import *import gmpy2n = 28247956190796077548821036165832051095182478841343849341201099128819479182033196745888916043527789810068912335285845353736774484336851382817061906161464410813261565043154569983001168979661397673033159029064565590415202266364668996185387927547647414609049665701634943970073424680262167057713264162243044242199992525550717430218592937779319306804366853371496949090902097569447358748738601201092248706444400984549491240349808244847814292328867056531536176757195282237815281620345660712787511847864860157060561247341926472934445937054346872777130907776700747053879719058858665504682167737096909091658310703848714995507087e1 = 14729696809459508716385569304221898763069627997586157384420106315856541102841676901689428248411442723122274238893709627729613555080244422116252212813081403190521848377387091820856797688344508117977167198575999802122072100976783815485227448685251402928453641606244138534312889639695831020684859444038879931443306689809413522781182634833029742866760422550903997471974167552388516014202843112478278655370138693696356621310668692751596233613748393311787483393850367208650431878268345462622307080790201460993914739555030933412223443727451306619192444521947087311524606746672804056939248534450817019868870802552074243882377e2 = 10907651584541464409470494737289836122935666586931706055595902003883184928824627549246585826596861981965927482456455737073705999708471130440398909870554351524288791148142553288839156753336551721274021596567766812030470532876231205718107266170708315964229471470530690537533600851746463150957473253899821019421342552091338365357017748742821451767352420328276163005698272017204771807428933429417340619373269170581813206653190286582334483827342338454461627946086922006705360281421384249860374825149668002500611584152958000206147344275567898096476692898681393229095674001876869497249423498186867190630700665116613171171985c = 14151986355027540236877811729876734276410473157789551074684191809631364271052357249861862424614207635605041553420473293592242919606316628442514124449901660763278200999279517540020047022360186952956318844301844675024175636253509419780669989143178706203706350138854046573467948881219084764605132312446701967740275650109903208220772228525117766500225573404421894020148747991820530966508849170593946661068452445685905577771836515980941955814291933511646362511812580324895180140431064196870852032763940873198931010750588123937360585160510295014722360134758829576304291022740315244570633962516612490451736612193602659033973kphi = e1 - e2 -1024*e1*e2d2 = gmpy2.invert(e1,kphi)m = pow(c,d2,n)print(long_to_bytes(m))#flag&#123;wh47_1F_1_H4V3_pr1v473_K3Y+X???&#125; 1024_密码系统1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# -*- coding:utf-8 -*-# Author:airrudderfrom Crypto.Cipher import DESfrom binascii import b2a_hex, a2b_hexfrom secret import FLAG,KEY,HINTfrom itertools import *import randomdef Encode_1024sys(data,key): data_list = [data[i:i+8] for i in range(0,len(data),8)] k1 = DES.new(key.encode(), DES.MODE_ECB) k2 = DES.new(key[::-1].encode(), DES.MODE_ECB) data_res = &#x27;&#x27; for i in range(0,len(data_list)): k = random.choice([k1,k2]) c = k.encrypt(data_list[i].encode()) data_res += b2a_hex(c).decode() #字符串转16进制 return data_resdef Encode_1024(data,key): len_data=len(data) choices = cycle(&#x27;1024&#x27;) while len_data%8!=0: #pad data += next(choices) len_data=len(data) data_res = Encode_1024sys(data,key) data_out = hex(int(data_res,16)**12 + random.randint(10**1023,10**1024))[2:] return data_outdef main(): menu = &#x27;&#x27;&#x27;1. Encode2. Verify your FLAG3. Exit&#x27;&#x27;&#x27; try: while True: print(menu) choice = input(&quot;&gt; &quot;) if choice == &quot;1&quot;: msg=input(&quot;Please input your msg: &quot;) data_out = Encode_1024(msg+FLAG,KEY) print(&quot;hex(Encode_1024(msg+flag)) is :&quot;,data_out) elif choice == &quot;2&quot;: yourFLAG = input(&#x27;Please input your FLAG: &#x27;) if yourFLAG == FLAG: print(HINT) else: print(&#x27;1024, nonono..., come on!!!&#x27;) elif choice == &quot;3&quot;: print(&quot;Bye!&quot;) return else: print(&quot;Invalid choice!&quot;) continue except: print(&#x27;error&#x27;) if __name__ == &quot;__main__&quot;: main() ​ 面向wp学习： 12345678910111213假设flag为 flag&#123;12345678&#125; #共14位填充后 flag&#123;12345678&#125;10 #16位，明文分组为“flag&#123;123”、“45678&#125;10”#flag前面的数据可控，假如填入的msg为“111”flag会被填充到 111flag&#123;12345678&#125;1024102 #共24位，明文分组为“111flag&#123;”、“12345678”、“&#125;1024102”#也就是说flag的最后一位“&#125;”就被挤出了原来的分组，总长度增加。而且最后一个明文分组为“&#125;1024102”。#那么假如我在一开始填入的msg为“&#125;1024102111”flag会被填充到 &#125;1024102111flag&#123;12345678&#125;1024102 #共32位，明文分组为“&#125;1024102”、“111flag&#123;”、“12345678”、“&#125;1024102”#这也就是说第一个明文分组和最后一个明文分组是一样的，所以ECB模式下，所对应的密文分组也一样。#所以对输入的msg逐位添加爆破即可爆破8位后，得到 2345678&#125;1024102111flag&#123;12345678&#125; #共32位#到第9位时，就需要比较第一个明文分组和倒数第二个明文分组所对应的密文分组是否一样了12345678&#125;1024102111flag&#123;12345678&#125;1024102 #共40位，明文分组“12345678”、“&#125;1024102”、“111flag&#123;”、“12345678”、“&#125;1024102”#同样的，到(8k+1)位是，需要比较第一个明文分组和倒数第(k+1)位的明文分组 ​ exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *import gmpy2import stringimport randomdef main(): try: sh = remote(&#x27;pwn.challenge.ctf.show&#x27;,28175) print(&#x27;\\n[+] 开始爆破FLAG&#x27;) FLAG = get_FLAG(sh) print(&#x27;\\n[+] 开始解密得到flag&#x27;) flag = yunying(FLAG) print(&#x27;flag&#123;&#x27;+flag.lower()+&#x27;&#125;&#x27;) except: print_msg() exit(0)def print_msg(): print(&#x27;=&#x27;*50) print(&#x27;Usage: python exp.py &lt;ip&gt; &lt;port&gt;&#x27;) print(&#x27; Eg: python exp.py 127.0.0.1 10248&#x27;) print(&#x27;=&#x27;*50)#验证FLAGdef verify_FLAG(sh,FLAG): sh.recvuntil(&#x27;&gt; &#x27;) sh.sendline(&#x27;2&#x27;) sh.recvuntil(&#x27;Please input your FLAG: &#x27;) sh.sendline(FLAG) data = sh.recvline().decode() if &#x27;nonono&#x27; not in data: print(&#x27;\\nHINT: &#x27;+data) return FLAG return 0def get_FLAG(sh): FLAG = &#x27;&#x27; table = &#x27;1024&#x27; # 不知道FLAG被分成几组，这里先爆破5组 for k in range(5): #DES分组，每组8字节 for j in range(8): #由于key有两个，不知道到底使用的哪一个，所以多循环几次爆破即可 while True: i = random.choice([&#x27;1&#x27;,&#x27;0&#x27;,&#x27;2&#x27;,&#x27;4&#x27;]) sh.recvuntil(&#x27;&gt; &#x27;) sh.sendline(&#x27;1&#x27;) sh.recvuntil(&#x27;Please input your msg: &#x27;) payload = i+FLAG+&#x27;1024102111&#x27; sh.sendline(payload) #接收到的data数据 data = sh.recvline().decode().split(&#x27; : &#x27;)[1][:-1] #print(data) datadec = int(data,16) #开方后十进制表示的数据 dec1024 = gmpy2.iroot(datadec,12) hex1024 = hex(dec1024[0])[2:] if (k==0 and hex1024[:16]==hex1024[-16:]) or hex1024[:16]==hex1024[-16*(k+1):-16*(k)]: FLAG = i+FLAG print(&#x27;\\rFLAG = &#x27;+FLAG,end=&#x27;&#x27;) if verify_FLAG(sh,FLAG): return FLAG break return 0#云影密码(01248密码)解密def yunying(FLAG): flag = &#x27;&#x27; strs = string.ascii_uppercase flag_list = FLAG.split(&#x27;0&#x27;) for j in flag_list: tmp = 0 for k in j: tmp += int(k) flag += strs[tmp-1] return flagif __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"赛事","slug":"赛事","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/"},{"name":"CTFshow-1024杯","slug":"赛事/CTFshow-1024杯","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/CTFshow-1024%E6%9D%AF/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"},{"name":"赛事","slug":"赛事","permalink":"http://example.com/tags/%E8%B5%9B%E4%BA%8B/"}]},{"title":"LFSR基本原理和简单题型","slug":"LFSR基本原理和简单题型","date":"2022-01-26T10:01:32.000Z","updated":"2022-01-27T07:18:33.974Z","comments":true,"path":"2022/01/26/LFSR基本原理和简单题型/","link":"","permalink":"http://example.com/2022/01/26/LFSR%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%80%E5%8D%95%E9%A2%98%E5%9E%8B/","excerpt":"​ 序列密码最重要的就是以某种规律产生大量密钥，而产生密钥流最重要的部件之一是反馈移位寄存器。其中反馈移位寄存器又分为线性反馈移位寄存器和非线性反馈移位寄存器，本篇主要介绍线性反馈移位寄存器（LFSR）的原理和基本题型。","text":"​ 序列密码最重要的就是以某种规律产生大量密钥，而产生密钥流最重要的部件之一是反馈移位寄存器。其中反馈移位寄存器又分为线性反馈移位寄存器和非线性反馈移位寄存器，本篇主要介绍线性反馈移位寄存器（LFSR）的原理和基本题型。 一.LFSR的优点1.LFSR适合硬件实现，代价小，收益大 2.它们能产生大的周期序列 3.它们能产生好的统计特性的序列 4.它们的结构能够应用代数方法进行分析 二.n级反馈移位寄存器的结构和原理 ​ LFSR的结构如图所示： ​ 其工作原理比较简单，移位寄存器用来存储数据，并受到系统时钟脉冲驱动。每一存储器称为移位存储器的一级，移位存储器中的个数称为移位存储器的级数。在某一时刻，所有寄存器的内容构成该反馈移位寄存器的一个状态，共有2^n种可能的状态，每一个状态对应于域GF（2）上的一个n维向量，用（a1，a2，…，an-1，an）表示，其中ai是当前时刻第i级存储器的内容。 ​ 在一个时间单位内，第i级寄存器ai的内容被传递给第i-1级寄存器ai-1（i=2，3，…），并根据寄存器当前的状态计算f(a1，a2，…，an)作为寄存器an下一个时刻的内容，其中f称为反馈函数，该函数是个n元布尔函数。 ​ 若f（a1，a2，…，an）是a1，a2等的线性函数，则这样的移位寄存器称为线性反馈移位寄存器，否则位非线性反馈移位寄存器。 ​ 若f为线性移位寄存器，则可以表示为： f（a1，a2，…，an）=Cn .a1+Cn-1 .a2+…+C1 .an 其中，Ci为0或者1，+为模2加法（异或运算），并且要满足Ci不全为0。举个例子如下： 三.基本题型举例[CISCN2018]oldstreamgame 12345678910111213141516171819202122232425262728flag = &quot;flag&#123;xxxxxxxxxxxxxxxx&#125;&quot;assert flag.startswith(&quot;flag&#123;&quot;)assert flag.endswith(&quot;&#125;&quot;)assert len(flag)==14 def lfsr(R,mask): output = (R &lt;&lt; 1) &amp; 0xffffffff #R进行左移，说明R即为初始状态 i=(R&amp;mask)&amp;0xffffffff lastbit=0 while i!=0: lastbit^=(i&amp;1) i=i&gt;&gt;1 output^=lastbit return (output,lastbit)R=int(flag[5:-1],16)mask = 0b10100100000010000000100010010100f=open(&quot;key&quot;,&quot;w&quot;)for i in range(100): tmp=0 for j in range(8): (R,out)=lfsr(R,mask) tmp=(tmp &lt;&lt; 1)^out f.write(chr(tmp))f.close()#输出（16进制序列）#20FDEEF8A4C9F4083F331DA8238AE5ED083DF0CB0E7A83355696345DF44D7C186C1F459BCE135F1DB6C76775D5DCBAB7A783E48A203C19CA25C22F60AE62B37DE8E40578E3A7787EB429730D95C9E1944288EB3E2E747D8216A4785507A137B413CD690C ​ LFSR类型的题目首先要确定移位周期，其实也就是寄存器的个数。题目中的R = int(flag[5:-1],16)，其长度为14-6 = 8 （个16进制数），说明寄存器的个数为8*4 = 32。 ​ 下一步要搞清楚移位寄存器的线性函数表达式，所以需要研究lfsr函数： output = (R &lt;&lt; 1) &amp; 0xffffffff：R（32位）循环左移一位 i=(R&amp;mask)&amp;0xffffffff：i为R与mask与运算的结果，由于mask大部分为0，所以i可能为1的位数只能为mask非0的位数，即mask从右向左第3、5、8、12、20、27、30、32位 lastbit^=(i&amp;1)：lastbit实际上等于i的每一位相异或，由于与0异或值不变，所以只考虑i中的1的数量，若1的数量为偶数，lastbit为0，若为奇数，则为1。又由于i可能为1的位数为以上几位，所以lastbit = 3^5^8^12^20^27^30^32（线性表达式）。 ​ 再分析输出流： 123456789 f=open(&quot;key&quot;,&quot;w&quot;)for i in range(100): tmp=0 for j in range(8): (R,out)=lfsr(R,mask) tmp=(tmp &lt;&lt; 1)^out f.write(chr(tmp))f.close() ​ 每8位lastbit组成一个字节，即一个字符，循环一百次，获得100个字符。 ​ 解题：综合以上分析，可以发现欲获得初始R的序列，需要找到R左移31次以后的状态，此时R的最低位在反馈寄存器的最高位，其他位都是由f连续生成的31位lastbit，那么可以通过异或的可逆性，获得R的最低位，依次可以获得R的倒数第二位…直到获得R的完整序列。 ​ exp： 123456789101112131415c = &quot;00100000111111011110111011111000&quot;s = &#x27;&#x27;for i in range(32): m = str(int(c[-4])^int(c[-6])^int(c[-9])^int(c[-13])^int(c[-21])^int(c[-28])^int(c[-31])^int(c[-1])) #这里需要仔细思考 s = s + m l = s[::-1] c = l + &#x27;00100000111111011110111011111000&#x27;[0:31-i]s = s[::-1]print(s)d = int(s,2)print(&#x27;flag&#123;&#x27;+str(hex(d))[2:]+&#x27;&#125;&#x27;)#flag&#123;926201d7&#125;","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"LFSR","slug":"比赛/LFSR","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/LFSR/"},{"name":"基本原理","slug":"比赛/LFSR/基本原理","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/LFSR/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"LFSR","slug":"LFSR","permalink":"http://example.com/tags/LFSR/"}]},{"title":"CTFshow-摆烂杯","slug":"CTFshow-摆烂杯","date":"2022-01-24T02:36:06.000Z","updated":"2022-01-25T23:57:05.720Z","comments":true,"path":"2022/01/24/CTFshow-摆烂杯/","link":"","permalink":"http://example.com/2022/01/24/CTFshow-%E6%91%86%E7%83%82%E6%9D%AF/","excerpt":"easy-peasy​ 签到题：","text":"easy-peasy​ 签到题： 1234567891011121314151617from Crypto.Util.number import *from secret import flagp = getPrime(1024)q = getPrime(1024)n = p * qprint(f&#x27;n = &#123;n&#125;&#x27;)l = len(flag)assert(l == 86)m = bytes_to_long(b&#x27;\\x00&#x27; * (l - 1) + flag + b&#x27;\\x00&#x27; * (l - 2))e = 3c = pow(m, e, n)print(f&#x27;c = &#123;c&#125;&#x27;)# n = 23570098360097260908266914080954003513706885568390448463720576188146956287111601604870247233822682630020002051748117520481402155749832096007629686239669192722978473890311246293580246256300691145653885805730865515297134808702766299205253761028235483781919393575836334910012714628455073300114978717047912395404034141622115001451888302617428376998024080880564792294546406688814397757714979980790018933407614160131827023349206138480523080173634617167828920519758917549492886733519381497665596997617399404664611446202014908853898043742964782757859701755202188366852773164911994663079171498909577012208742001609095258401847# c = 7802816471025387606454709075933309958303134972861203739854774032383575355964299097074709350633475519273512630813578801152996777689686451397201513854823239337669091889776200179028891111154423623765139235199507280104544068425347533121731521700106757148551520759776111224072064131087547685154285120156917449926992033491342535410929828988598182819897435365878832122138552492908774845437576910276499625679469289655841639181182040186931130789588869657335253479416209378458303531995734157105918063227453396477282662136225029972745246845372963076381252679409317314514131852117346576265346926741908194011319430767975281696400 ​ 小指数加密的变种，先移位再进行小指数加密。解法就是先把移位扩大的倍数求逆（模除法），再小指数开方就可。 123456789101112131415161718from Crypto.Util.number import *import gmpy2# a = b&#x27;\\x00\\01\\x00\\x00&#x27;# print(bytes_to_long(a))c = 7802816471025387606454709075933309958303134972861203739854774032383575355964299097074709350633475519273512630813578801152996777689686451397201513854823239337669091889776200179028891111154423623765139235199507280104544068425347533121731521700106757148551520759776111224072064131087547685154285120156917449926992033491342535410929828988598182819897435365878832122138552492908774845437576910276499625679469289655841639181182040186931130789588869657335253479416209378458303531995734157105918063227453396477282662136225029972745246845372963076381252679409317314514131852117346576265346926741908194011319430767975281696400n = 23570098360097260908266914080954003513706885568390448463720576188146956287111601604870247233822682630020002051748117520481402155749832096007629686239669192722978473890311246293580246256300691145653885805730865515297134808702766299205253761028235483781919393575836334910012714628455073300114978717047912395404034141622115001451888302617428376998024080880564792294546406688814397757714979980790018933407614160131827023349206138480523080173634617167828920519758917549492886733519381497665596997617399404664611446202014908853898043742964782757859701755202188366852773164911994663079171498909577012208742001609095258401847k = pow(16,504)o = gmpy2.invert(k,n)o1 = o*co1 = o1 % nfor i in range(1000000): m = gmpy2.iroot(o1+i*n,3)[0] if(long_to_bytes(m))[:3] == b&quot;ctf&quot;: print(long_to_bytes(m))#ctfshow&#123;345Y_p345Y_4_p13C3_OF_R54_1f_you_533_7H15_yOU_W1ll_KnoW_hoW_7o_5oLV3_17_R1gh7&#125; 你不知道的事123456789#!/usr/bin/env python3from Crypto.Util.number import*from secret import p, q, r, m_liste = 0x10001n = p*qnn = pow(p + q, 2)with open(&quot;output.txt&quot;, &quot;w&quot;) as f: tuple(map(lambda x: f.write(f&#x27;&#123;x&#125;\\n&#x27;), (n, (nn - q * (2*p + q)) * r, [pow(r*bytes_to_long(msg), e, n) for msg in m_list]))) ​ 先破解msg的内容，分析过程： ​ exp1： 1234567891011121314151617181920212223242526msg = []e = 0x10001n = ...n0 = ...#化简得p**2 * r = n0p = gmpy2.gcd(n,n0)r = n0//p**2q = n//pphi = (p-1)*(q-1)d = gmpy2.invert(e,phi)for i in msg: m = pow(i,d,n)//r print(long_to_bytes(m)) # F:\\python3.9\\python.exe C:/Users/CTF/PycharmProjects/摆烂杯—你不知道的事/main.pyb&quot;# We&#x27;re no strangers to love,\\n&quot;b&#x27;# You know the rules and so do I.\\n&#x27;b&quot;# A full commitment&#x27;s what I&#x27;m thinking of,\\n&quot;b&quot;# You wouldn&#x27;t get this from any other guy.\\n&quot;b&#x27;from Crypto.Util.number import *\\n&#x27;b&#x27;from sympy import nextprime\\n&#x27;b&#x27;flag = we_know_each_other_for_so_long\\n&#x27;b&quot;flag1 = flag[:len(flag) // 2] + __import__(&#x27;os&#x27;).urandom(88)\\n&quot;b&quot;flag2 = flag[len(flag) // 2:] + __import__(&#x27;os&#x27;).urandom(88)\\n&quot;b&#x27;p = nextprime(bytes_to_long(flag1))\\n&#x27;b&#x27;q = nextprime(bytes_to_long(flag2))\\n&#x27; ​ 根据输出的msg内容我们知道flag为flag1和flag2两部分组成，并且p和q就是flag1，2的整数的下一个素数。由于下一个素数大小与本数的差距并不大，只影响低位，于是可以直接将p和q转化成字节，可以看到高位部分就是flag： 1b&quot;ctfshow&#123;086c67cb-a132-4\\x88\\x0b\\n:r\\xfc\\x01)\\xe6&#x27;\\xccI\\x1e@_\\xf1\\x80\\x9c\\xa8\\xb5\\xdc\\x0fr\\xeb\\x8c\\x11\\xd8UWr\\x82\\xb7\\xdd\\xbe\\xd6&#123;V&#x27;\\xcf\\xbc\\xeb\\x85\\xdcCh\\xfcT\\xbdK\\x16\\xb6\\xa1\\xf7\\x06t1j\\x95)\\x00\\xa3\\xc6MKk@\\xcc\\xe2\\xe03\\xe1\\xee\\x8e\\xf1\\xa0\\xcf\\xef\\xca\\xa1\\xac@\\x1d\\xb2n\\nI\\xc8a&quot; b&#x27;509-8b6b-6c46386487dc&#125;\\n\\xf3\\x15\\x99J\\xa4\\n&#125;\\x1f_ J\\xcdMu\\xb6\\x1d0\\x06\\x18\\xe5\\x8b&amp;yJ\\xee\\xe7\\x94L\\x96\\x119\\xa5`~\\x9a&lt;\\xfdl\\x88q\\xf8Y&quot;\\xe8\\x83\\x970\\xa9\\&#x27;3hP\\x1d\\xc3\\x16C\\x016Y\\xcf\\xebQe\\x99\\x9b&amp;\\xf6\\xf0\\xdd\\x81\\x19\\xbb9\\xba\\xbf\\x1d\\x07l\\x16\\xbb\\xe8\\xf4\\xe0`ot\\xa9\\x8d&#x27; 春哥VS曾哥​ 关于模运算的问题，需要根据服务端给出的数值对进行分类讨论： 123456789101112131415161718192021from pwn import *p=remote(&#x27;pwn.challenge.ctf.show&#x27;,28020)def pwn(): a=str(p.recvline()) b=a.find(&#x27;= (&#x27;) c=a.find(&#x27;,&#x27;,9) d=int(a[b+3:c])#x e=int(a[c+2:-4])#y if(d&gt;=e): p.sendline(str(d+e)) else: f=e%d g=(e-f)//d h=g*d+f//2 p.sendline(str(h))for i in range(233): pwn() print(&#x27;进行了&#x27;,i,&#x27;轮验证&#x27;)p.interactive()#flag: ctfshow&#123;f28a4698-124e-4625-9a46-a92ff3c13756&#125;","categories":[{"name":"赛事","slug":"赛事","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/"},{"name":"CTFshow-摆烂杯","slug":"赛事/CTFshow-摆烂杯","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/CTFshow-%E6%91%86%E7%83%82%E6%9D%AF/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"},{"name":"赛事","slug":"赛事","permalink":"http://example.com/tags/%E8%B5%9B%E4%BA%8B/"}]},{"title":"CTFshow-月饼杯","slug":"CTFshow-月饼杯","date":"2022-01-19T11:09:31.000Z","updated":"2022-01-19T12:30:54.133Z","comments":true,"path":"2022/01/19/CTFshow-月饼杯/","link":"","permalink":"http://example.com/2022/01/19/CTFshow-%E6%9C%88%E9%A5%BC%E6%9D%AF/","excerpt":"crypto1_中秋月","text":"crypto1_中秋月 ​ 题目以及hint： 密文： hint：某古典密码；经此古典密码加密后，密文还是大写；keyword+plaintext (+plaintext…+plaintext)；自动钥匙⊕；明文全大写，得到后转小写，并以_连接单词 ​ ⊕符号通常就是异或的表示，根据题意应该是明文经过加密以后（大写字母）还经过了异或才得到当前的密文，所以可以先尝试还原异或之前的大写字母： 123456789s=&#x27;fsskryenvkm~jl&#123;ejs&#125;jwflzsnpgmifq&#123;&#123;j&#123;|suhzrjppnx|qvixt~whu&#x27;for i in range(255): res=&#x27;&#x27; for j in range(0,len(s)): temp = ord(s[j])^i if 65&lt;=temp&lt;=90 : #由大小写字母构成 res += (chr(temp)) if len(res)==len(s): print(res) ​ 得到：YLLTMFZQITRAUSDZULBUHYSELQOXRVYNDDUDCLJWEMUOOQGCNIVGKAHWJ ​ 根据keyword+plaintext (+plaintext…+plaintext)可知该加密算法为autokey密码，是一种多表替换密码，与维吉尼亚密码密码类似。对于替换类密码的破解github上有一个项目：python_cryptanalysis ​ 由于该项目仅支持python2，于是适当修改源码运行得到flag ​ 解密完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#main.pyfrom ngram_score import ngram_scorefrom pycipher import Autokeyimport refrom itertools import permutationss=&#x27;fsskryenvkm~jl&#123;ejs&#125;jwflzsnpgmifq&#123;&#123;j&#123;|suhzrjppnx|qvixt~whu&#x27;for i in range(255): res=&#x27;&#x27; for j in range(0,len(s)): temp = ord(s[j])^i if 65&lt;=temp&lt;=90 : #由大小写字母构成 res += (chr(temp)) if len(res)==len(s): print(res)qgram = ngram_score(&#x27;quadgrams.txt&#x27;)trigram = ngram_score(&#x27;trigrams.txt&#x27;)ctext = &#x27;YLLTMFZQITRAUSDZULBUHYSELQOXRVYNDDUDCLJWEMUOOQGCNIVGKAHWJ&#x27;ctext = re.sub(r&#x27;[^A-Z]&#x27;, &#x27;&#x27;, ctext.upper())class nbest(object): def __init__(self, N=1000): self.store = [] self.N = N def add(self, item): self.store.append(item) self.store.sort(reverse=True) self.store = self.store[:self.N] def __getitem__(self, k): return self.store[k] def __len__(self): return len(self.store)# initN=100for KLEN in range(3,20): rec = nbest(N) for i in permutations(&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;,3): key = &#x27;&#x27;.join(i) + &#x27;A&#x27;*(KLEN-len(i)) pt = Autokey(key).decipher(ctext) score = 0 for j in range(0,len(ctext),KLEN): score += trigram.score(pt[j:j+3]) rec.add((score,&#x27;&#x27;.join(i),pt[:30])) next_rec = nbest(N) for i in range(0,KLEN-3): for k in range(N): for c in &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;: key = rec[k][1] + c fullkey = key + &#x27;A&#x27;*(KLEN-len(key)) pt = Autokey(fullkey).decipher(ctext) score = 0 for j in range(0,len(ctext),KLEN): score += qgram.score(pt[j:j+len(key)]) next_rec.add((score,key,pt[:30])) rec = next_rec next_rec = nbest(N) bestkey = rec[0][1] pt = Autokey(bestkey).decipher(ctext) bestscore = qgram.score(pt) for i in range(N): pt = Autokey(rec[i][1]).decipher(ctext) score = qgram.score(pt) if score &gt; bestscore: bestkey = rec[i][1] bestscore = score print (bestscore,&#x27;autokey, klen&#x27;,KLEN,&#x27;:&quot;&#x27;+bestkey+&#x27;&quot;,&#x27;,Autokey(bestkey).decipher(ctext).lower()) #ngram_score.pyfrom math import log10class ngram_score(object): def __init__(self,ngramfile,sep=&#x27; &#x27;): &#x27;&#x27;&#x27; load a file containing ngrams and counts, calculate log probabilities &#x27;&#x27;&#x27; self.ngrams = &#123;&#125; for line in open(ngramfile): key,count = line.split(sep) self.ngrams[key] = int(count) self.L = len(key) #print(self.ngrams.items()) self.N = sum(self.ngrams.values()) #calculate log probabilities for key in self.ngrams.keys(): self.ngrams[key] = log10(float(self.ngrams[key])/self.N) self.floor = log10(0.01/self.N) def score(self,text): &#x27;&#x27;&#x27; compute the score of text &#x27;&#x27;&#x27; score = 0 ngrams = self.ngrams.__getitem__ for i in range(len(text)-self.L+1): if text[i:i+self.L] in self.ngrams: score += ngrams(text[i:i+self.L]) else: score += self.floor return score crypto2_月自圆​ 题目： 123456789101112131415161718192021222324# -*- coding:utf-8 -*-#Author: Lazzarofrom itertools import *from random import *from string import *def encrypt(m, a, si): c=&quot;&quot; for i in range(len(m)): c+=hex(((ord(m[i])) * a + ord(next(si))) % 128)[2:].zfill(2) #zfill函数是将字符串右对齐指定长度，用0填充左边 return c if __name__ == &quot;__main__&quot;: m = &#x27;****************************************************flag&#123;*************&#125;&#x27; assert(len(m)==71) a = randint(50,100) salt = &#x27;&#x27;.join(sample(ascii_uppercase, 4))#随机抽4个大写字母 si = cycle(salt.lower()) c=encrypt(m, a, si) print(c) #3472184e657e50561c481f5c1c4e1938163e154431015e13062c1b073d4e3a444f4a5c5c7a071919167b034e1c29566647600c4e1c2956661b6c1f50622f0016317e563546202a ​ 由题目得flag长度为71，密文为172，一位明文对应两位密文 ​ 这里由于a不大，salt长度也不长，且明文m中存在flag，正好可以用这几位去爆破出a和salt；flag在明文m中的位置是53，对应密文c中的位置是105；因此可以遍历si（26位字母）和a（50~100） 1234567891011121314151617from itertools import *def decrypt(m, a, si): c=&quot;&quot; for i in range(len(m)): c+=hex(((ord(m[i])) * a + ord(next(si))) % 128)[2:].zfill(2) return cif __name__ == &quot;__main__&quot;: for i in range(50,100): for j in ascii_uppercase: si = cycle(j.lower()) # if encrypt(&#x27;f&#x27;, i, si)==&#x27;1c&#x27;: # print(&#x27;i =&#x27;,i,&#x27;\\tj =&#x27;,j) if decrypt(&#x27;l&#x27;, i, si)==&#x27;29&#x27;: print(&#x27;i =&#x27;,i,&#x27;\\tj =&#x27;,j) ​ 通过字母f爆破的结果： i = 52 j = Di = 57 j = Fi = 62 j = Hi = 67 j = Ji = 72 j = Li = 77 j = Ni = 82 j = Pi = 87 j = Ri = 92 j = Ti = 97 j = V ​ 通过字母l爆破的结果： i = 54 j = Ai = 55 j = Ui = 61 j = Mi = 67 j = Ei = 68 j = Yi = 74 j = Qi = 80 j = Ii = 86 j = Ai = 87 j = Ui = 93 j = Mi = 99 j = E ​ 取两者的交集：a = 67 ​ 再利用a爆破salt的另外两位： 12345if decrypt(&#x27;a&#x27;, 67, si)==&#x27;56&#x27;: print(&#x27;j =&#x27;,j)if decrypt(&#x27;g&#x27;, 67, si)==&#x27;66&#x27;: print(&#x27;j =&#x27;,j) ​ 得到构成salt的字符为“J、E、S、Q”，又f字母是第53个，前边共52个字母是4的倍数，于是可以确定salt就为“JESQ” ​ 解密exp： 123456789101112131415161718192021from itertools import *if __name__ == &quot;__main__&quot;: a=67 salt = &#x27;JESQ&#x27; si = cycle(salt.lower()) c = &#x27;3472184e657e50561c481f5c1c4e1938163e154431015e13062c1b073d4e3a444f4a5c5c7a071919167b034e1c29566647600c4e1c2956661b6c1f50622f0016317e563546202a&#x27; q=len(c)//2 s=&#x27;&#x27; for i in range(q): b=c[:2] c=c[2:] sm=next(si) for k in range(1,126): m=chr(k) c1=hex(((ord(m)) * a + ord(sm)) % 128)[2:].zfill(2) #print(m,c1,int(c1,base=16)==int(b,base=16)) if(int(c1,base=16)==int(b,base=16)): s+=m break print(s) now_is_7fad9fcb-d361-4964-821c-177c906b8d20_flag_is_flag{md5(now-salt)} ​ 最后把now（7fad9fcb-d361-4964-821c-177c906b8d20）和salt拼接起来进行md5加密就得到flag{}里面包裹的内容。 crypto3_多少离怀​ 题目： 1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-#Author: Lazzarofrom Crypto.Util.number import getPrime,isPrimefrom math import gammaimport randomdef nextPrime(n): n += 2 if n &amp; 1 else 1 while not isPrime(n): n += 2 return ndef getNewPrime(): A = getPrime(512) B = nextPrime(A - random.randint(1e4,1e5)) return nextPrime(gamma(B+2)%A) p = getNewPrime()q = getNewPrime()r = getNewPrime()n = p * q ** 2 * r ** 3e = 0x10001c = pow(flag,e,n)#pA=6814157460586876042804041951834304833424062437744287469257313954502540797027261340622077218188033865281590529907571701131297782609357118357982463723982789#pB=6814157460586876042804041951834304833424062437744287469257313954502540797027261340622077218188033865281590529907571701131297782609357118357982463723922147#qA=7145646366857234331692232566211321498245533826533958883943688415057871253511271731661019642050252046201115975396366275083424623329930477623781348477881291#qB=7145646366857234331692232566211321498245533826533958883943688415057871253511271731661019642050252046201115975396366275083424623329930477623781348477807457#n=4451906216583258787166698210560165433649728830889954633721198623488802305844782492171757604711145165920462286487680020347239300947225371917344589502941576734875830871998499135120227347066586066943289430156378296665669974728569678779668142712266780949126509440672273927433367293606776081254094682033167575930701870261219046464773708974194213798032346187463443317770758989273370488582862531630356263732232300508706676725203199729764016766683870925164232508407363688370458877688991733322055785233669885166225464068579486683574954699370175267031949720967812902215635630884502987094547523361027411501285252862476410213277925430392164226297316310465146003494714018456407793759170649913180823814850170639706664167149612984905056804131124522209409607977589884632999710708045656852149371030046919242039957767777840304466948549383597755811307383659188216421501912831203089570725388153416013596114462069777713822433178099904907224119#c=1996198968748552041728429851810599627895157160099076033250854211280074825148767841655949210593646824507865483166496070951130337321360509148527292165245205219296211294789087358959553387392928560150390604911087085313000622842025416521494799132969818997182731021267942464323979261593380113740152841984062184326431879167516288834455296913822921806893572566867611541664848820247889274979245086440402996661226884320574824077910315143756471444347386795428338020162169391827182914043434253974549636668126789355991920452920806351939782281969098470635517019120996509180703896707990501216102290302162705699788457579330150149320348175742131887213742989509004374645723471497302400169849858253644606818874098604333865973357374444445825761600866472906771935670261641342221394488068630591190697667016958881530367047928341661857241378511420562236766886349565409774340321441504290366223243635878057759623855735794209219474650425139791831374 ​ hint给了要用到威尔逊定理，于是复习了一下： 在初等数论中，威尔逊定理给出了判定一个自然数是否素数的充分必要条件。即：当且仅当p为素数时：( p -1 )! ≡ -1 ( mod p ) ​ 推导过程： ​ exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from math import gammaimport randomimport gmpy2import binasciifrom Cryptodome.Util.number import *def nextPrime(n): n += 2 if n &amp; 1 else 1 while not isPrime(n): n += 2 return ndef getNewPrime(): A = getPrime(512) B = nextPrime(A - random.randint(1e4,1e5)) return nextPrime(gamma(B+2)%A)pA=6814157460586876042804041951834304833424062437744287469257313954502540797027261340622077218188033865281590529907571701131297782609357118357982463723982789pB=6814157460586876042804041951834304833424062437744287469257313954502540797027261340622077218188033865281590529907571701131297782609357118357982463723922147qA=7145646366857234331692232566211321498245533826533958883943688415057871253511271731661019642050252046201115975396366275083424623329930477623781348477881291qB=7145646366857234331692232566211321498245533826533958883943688415057871253511271731661019642050252046201115975396366275083424623329930477623781348477807457e = 0x10001n=4451906216583258787166698210560165433649728830889954633721198623488802305844782492171757604711145165920462286487680020347239300947225371917344589502941576734875830871998499135120227347066586066943289430156378296665669974728569678779668142712266780949126509440672273927433367293606776081254094682033167575930701870261219046464773708974194213798032346187463443317770758989273370488582862531630356263732232300508706676725203199729764016766683870925164232508407363688370458877688991733322055785233669885166225464068579486683574954699370175267031949720967812902215635630884502987094547523361027411501285252862476410213277925430392164226297316310465146003494714018456407793759170649913180823814850170639706664167149612984905056804131124522209409607977589884632999710708045656852149371030046919242039957767777840304466948549383597755811307383659188216421501912831203089570725388153416013596114462069777713822433178099904907224119c=1996198968748552041728429851810599627895157160099076033250854211280074825148767841655949210593646824507865483166496070951130337321360509148527292165245205219296211294789087358959553387392928560150390604911087085313000622842025416521494799132969818997182731021267942464323979261593380113740152841984062184326431879167516288834455296913822921806893572566867611541664848820247889274979245086440402996661226884320574824077910315143756471444347386795428338020162169391827182914043434253974549636668126789355991920452920806351939782281969098470635517019120996509180703896707990501216102290302162705699788457579330150149320348175742131887213742989509004374645723471497302400169849858253644606818874098604333865973357374444445825761600866472906771935670261641342221394488068630591190697667016958881530367047928341661857241378511420562236766886349565409774340321441504290366223243635878057759623855735794209219474650425139791831374#求 ((pA-2)!/(pB+1)!)%pA 的逆元，等于((pB+1)!)%pA ，等于gamma(pB+2)%pAp = 1max = (pA-2) - (pB+1)for i in range(0,max): p = p * gmpy2.invert((pA-i-2),pA) % pAp = nextPrime(p)#求 ((qA-2)!/(qB+1)!)%qA 的逆元，等于((qB+1)!)%qA ，等于gamma(qB+2)%qAq = 1max = (qA-2) - (qB+1)for i in range(0,max): q = q * gmpy2.invert((qA-i-2),qA) % qAq = nextPrime(q)r = gmpy2.iroot(gmpy2.mpz(n//(p*q**2)),3)print(r)print(&#x27;p =&#x27;,p)print(&#x27;q =&#x27;,q)print(&#x27;r =&#x27;,r[0])phi = (p-1)*(q**2-q)*(r[0]**3-r[0]**2)d = gmpy2.invert(e,phi)m = pow(c, d, n)print(long_to_bytes(m))","categories":[{"name":"赛事","slug":"赛事","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/"},{"name":"CTFshow-月饼杯","slug":"赛事/CTFshow-月饼杯","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/CTFshow-%E6%9C%88%E9%A5%BC%E6%9D%AF/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"},{"name":"赛事","slug":"赛事","permalink":"http://example.com/tags/%E8%B5%9B%E4%BA%8B/"}]},{"title":"CTFshow-ROARCTF-Reverse","slug":"CTFshow-ROARCTF-Reverse","date":"2022-01-18T03:06:27.000Z","updated":"2022-01-19T15:35:31.896Z","comments":true,"path":"2022/01/18/CTFshow-ROARCTF-Reverse/","link":"","permalink":"http://example.com/2022/01/18/CTFshow-ROARCTF-Reverse/","excerpt":"​ 根据题目所给算法，通过递归爆破获得p，q破解密文。","text":"​ 根据题目所给算法，通过递归爆破获得p，q破解密文。 ​ 题目： 12345678910111213141516171819202122232425from Crypto.Util.number import *from gmpy2 import *from secret import *assert(flag.decode().startswith(&#x27;flag&#123;&#x27;)) and (flag.decode().endswith(&#x27;&#125;&#x27;))def reverse(x): y = 0 while x != 0: y = y*2 + x%2 x = x // 2 return ywhile True: p = getStrongPrime(512) q = reverse(p) if is_prime(q): breakn = p*qe = 65537m = bytes_to_long(flag)enc = powmod(m,e,n)#n = 158985980192501034004997692253209315116841431063210516613522548452327355222295231366801286879768949611058043390843949610463241574886852164907094966008463721486557469253652940169060186477803255769516068561042756903927308078335838348784208212701919950712557406983012026654876481867000537670622886437968839524889#enc = 103728452309804750381455306214814700768557462686461157761076359181984554990431665209165298725569861567865645228742739676539208228770740802323555281253638825837621845841771677911598039696705908004858472132222470347720085501572979109563593281375095145984000628623881592799662103680478967594601571867412886606745 ​ 实际上reverse（）的作用就是将传入参数的二进制表示倒序排列形成一个新的数，因此题目中的p和q是512位长度且01序列顺序相反的2进制数；所以我们可以通过遍历p（512位）的01序列（因为顺序相反，其实也在遍历q），并与n的二进制表示得到每一位进行比对，来获得p、q的值。 ​ exp： 12345678910111213141516171819202122232425262728293031323334353637from Crypto.Util.number import *import gmpy2n = 158985980192501034004997692253209315116841431063210516613522548452327355222295231366801286879768949611058043390843949610463241574886852164907094966008463721486557469253652940169060186477803255769516068561042756903927308078335838348784208212701919950712557406983012026654876481867000537670622886437968839524889c = 103728452309804750381455306214814700768557462686461157761076359181984554990431665209165298725569861567865645228742739676539208228770740802323555281253638825837621845841771677911598039696705908004858472132222470347720085501572979109563593281375095145984000628623881592799662103680478967594601571867412886606745e = 65537def Brute_force(a, b, k): if k == 256: if a * b == n:#跳出递归的条件 print(a, b) return 0 for i in range(2): for j in range(2): a1 = a + i * (2 ** (511 - k)) + j * (2 ** k) b1 = b + j * (2 ** (511 - k)) + i * (2 ** k) #限制条件一，加快爆破速度 if a1 * b1 &gt; n: continue #限制条件二，加快爆破速度 if (a1 + 2 ** (511 - k)) * ((b1 + 2 ** (511 - k))) &lt; n: continue #这个条件限制n从低位到高位的每一位和爆破出来的每一位相等，是不可缺少的限制条件 if (a1 * b1) % (2 ** (k + 1)) != n % (2 ** (k + 1)): continue Brute_force(a1, b1, k + 1) return 0Brute_force(0, 0, 0)p = 11954360020159164180709939019047385560179850436770100207193049651260543609501871575909448998378290922795824941066935928157032997160163537467165365731882943q = 13299413764048930133302138749466137829470129709829516069778014310838093114516400589047888072065037035007023741009041669893387899867083575829855377403280423phi = (p-1)*(q-1)d = gmpy2.invert(e,phi)flag = long_to_bytes(pow(c,d,n))print(flag) flag{b92d9b6c-e75d-4cbb-bc39-bf39a2f57c3f}","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"}]},{"title":"TEA、XTEA、XXTEA加解密","slug":"TEA、XTEA、XXTEA加解密","date":"2022-01-13T02:55:59.000Z","updated":"2022-01-13T04:26:25.164Z","comments":true,"path":"2022/01/13/TEA、XTEA、XXTEA加解密/","link":"","permalink":"http://example.com/2022/01/13/TEA%E3%80%81XTEA%E3%80%81XXTEA%E5%8A%A0%E8%A7%A3%E5%AF%86/","excerpt":"算法简介 TEA(Tiny Encryption Algorithm) 是一种简单高效的分组加密算法，以加密解密速度快，实现简单著称，因为其以异或和模加运算为基础，这两种运算计算机实现的效率很高。TEA算法每一次可以操作64-bit(8-byte)，采用128-bit(16-byte)作为key，算法采用迭代的形式，推荐的迭代轮数是64轮，最少32轮。","text":"算法简介 TEA(Tiny Encryption Algorithm) 是一种简单高效的分组加密算法，以加密解密速度快，实现简单著称，因为其以异或和模加运算为基础，这两种运算计算机实现的效率很高。TEA算法每一次可以操作64-bit(8-byte)，采用128-bit(16-byte)作为key，算法采用迭代的形式，推荐的迭代轮数是64轮，最少32轮。 ​ TEA 算法最初是由剑桥计算机实验室的 David Wheeler 和 Roger Needham 在 1994 年设计的。该算法使用 128 位的密钥为 64 位的信息块进行加密，它需要进行 64 轮迭代，尽管作者认为 32 轮已经足够了。该算法使用了一个神秘常数δ作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但δ的精确值似乎并不重要，这里 TEA 把它定义为 δ=「(√5 - 1)231」（也就是程序中的 0×9E3779B9）。 ​ 之后 TEA 算法被发现存在缺陷，作为回应，设计者提出了一个 TEA 的升级版本——XTEA（有时也被称为“tean”）。XTEA 跟 TEA 使用了相同的简单运算，但它采用了截然不同的顺序，为了阻止密钥表攻击，四个子密钥（在加密过程中，原 128 位的密钥被拆分为 4 个 32 位的子密钥）采用了一种不太正规的方式进行混合，但速度更慢了。 ​ 在跟描述 XTEA 算法的同一份报告中，还介绍了另外一种被称为 Block TEA 算法的变种，它可以对 32 位大小任意倍数的变量块进行操作。该算法将 XTEA 轮循函数依次应用于块中的每个字，并且将它附加于它的邻字。该操作重复多少轮依赖于块的大小，但至少需要 6 轮。该方法的优势在于它无需操作模式（CBC，OFB，CFB 等），密钥可直接用于信息。对于长的信息它可能比 XTEA 更有效率。 ​ 在 1998 年，Markku-Juhani Saarinen 给出了一个可有效攻击 Block TEA 算法的代码，但之后很快 David J. Wheeler 和 Roger M. Needham 就给出了 Block TEA 算法的修订版，这个算法被称为 XXTEA。XXTEA 使用跟 Block TEA 相似的结构，但在处理块中每个字时利用了相邻字。它利用一个更复杂的 MX 函数代替了 XTEA 轮循函数，MX 使用 2 个输入量。 TEA加密算法​ TEA的分组长度为64位，密钥长度为128位，采用Feistel网络，建议32次循环加密即64轮。Feistel网络是一种分组密码常用的结构，其特点为明文分为等长两组，每一轮只加密一半，其安全性与密钥长度、分组长度、轮函数复杂度等有关。使用Feistel网络的密码算法，解密与加密流程类似，通常解密只需要用加密使用的硬件或者软件进行适当修改即可，提高效率降低成本。其结构如下所示： ​ TEA的加密流程图解： ​ 加解密C实现： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;void encrypt(unsigned int* v, unsigned int* key) &#123; unsigned int l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9; for (size_t i = 0; i &lt; 32; i++) &#123; sum += delta; l += ((r &lt;&lt; 4) + key[0]) ^ (r + sum) ^ ((r &gt;&gt; 5) + key[1]); r += ((l &lt;&lt; 4) + key[2]) ^ (l + sum) ^ ((l &gt;&gt; 5) + key[3]); &#125; v[0] = l; v[1] = r;&#125; void decrypt(unsigned int* v, unsigned int* key) &#123; unsigned int l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9; sum = delta *32; for (size_t i = 0; i &lt; 32; i++) &#123; r -= ((l &lt;&lt; 4) + key[2]) ^ (l + sum) ^ ((l &gt;&gt; 5) + key[3]); l -= ((r &lt;&lt; 4) + key[0]) ^ (r + sum) ^ ((r &gt;&gt; 5) + key[1]); sum -= delta; &#125; v[0] = l; v[1] = r;&#125;//注意，这种写法是把两轮加密合为一轮来写的，所以写法与des有些不同int main(int argc, char const *argv[])&#123; //test unsigned int v[2]=&#123;1,2&#125;,key[4]=&#123;1,2,3,4&#125;; printf(&quot;%u,%u\\n&quot;,v[0],v[1]); encrypt(v,key); printf(&quot;%u,%u\\n&quot;,v[0],v[1]); decrypt(v,key); printf(&quot;%u,%u\\n&quot;,v[0],v[1]); return 0;&#125; XTEA加密算法​ XTEA是TEA的扩展，同样是一个64位块的Feistel密码，使用128位密钥，建议64轮。 ​ 加密流程图解： ​ 加解密C实现： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;void encrypt(unsigned int* v, unsigned int* key) &#123; unsigned int l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9; for (size_t i = 0; i &lt; 32; i++) &#123; l += (((r &lt;&lt; 4) ^ (r &gt;&gt; 5)) + r) ^ (sum + key[sum &amp; 3]); sum += delta; r += (((l &lt;&lt; 4) ^ (l &gt;&gt; 5)) + l) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]); &#125; v[0] = l; v[1] = r;&#125; void decrypt(unsigned int* v, unsigned int* key) &#123; unsigned int l = v[0], r = v[1], sum = 0, delta = 0x9e3779b9; sum = delta * 32; for (size_t i = 0; i &lt; 32; i++) &#123; r -= (((l &lt;&lt; 4) ^ (l &gt;&gt; 5)) + l) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; l -= (((r &lt;&lt; 4) ^ (r &gt;&gt; 5)) + r) ^ (sum + key[sum &amp; 3]); &#125; v[0] = l; v[1] = r;&#125; int main(int argc, char const *argv[])&#123; //test unsigned int v[2]=&#123;1,2&#125;,key[4]=&#123;1,2,3,4&#125;; printf(&quot;%u,%u\\n&quot;,v[0],v[1]); encrypt(v,key); printf(&quot;%u,%u\\n&quot;,v[0],v[1]); decrypt(v,key); printf(&quot;%u,%u\\n&quot;,v[0],v[1]); return 0;&#125; XXTEA加密算法​ XXTEA是一个非平衡Feistel网络分组密码，在可变长度块上运行，这些块是32位大小的任意倍数（最小64位），使用128位密钥。 ​ 加密流程图解： ​ 加解密C实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #define DELTA 0x9e3779b9 #define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) &#123; uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ &#123; rounds = 6 + 52/n; sum = 0; z = v[n-1]; do &#123; sum += DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p=0; p&lt;n-1; p++) &#123; y = v[p+1]; z = v[p] += MX; &#125; y = v[0]; z = v[n-1] += MX; &#125; while (--rounds); &#125; else if (n &lt; -1) /* Decoding Part */ &#123; n = -n; rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) &#123; z = v[p-1]; y = v[p] -= MX; &#125; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds); &#125; &#125; int main() &#123; uint32_t v[2]= &#123;1,2&#125;; uint32_t const k[4]= &#123;2,2,3,4&#125;; int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); btea(v, n, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); btea(v, -n, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0; &#125;","categories":[{"name":"其它加密算法","slug":"其它加密算法","permalink":"http://example.com/categories/%E5%85%B6%E5%AE%83%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"}]},{"title":"长安战疫安全竞赛","slug":"西安战疫安全竞赛","date":"2022-01-09T05:21:12.000Z","updated":"2022-02-12T07:41:34.782Z","comments":true,"path":"2022/01/09/西安战疫安全竞赛/","link":"","permalink":"http://example.com/2022/01/09/%E8%A5%BF%E5%AE%89%E6%88%98%E7%96%AB%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B/","excerpt":"​ 题目不算难，获得了证书但成绩不算好，密码学应该要ak的，还是不够专注吧，做一半就跑去看杂项了。学到很多东西，遇到了CTF拿到国奖和国际奖以及AI发paper、机器人竞赛国二的大大大大佬，也认识了初中就能参加春秋杯进前十的小可爱…人外有人，天外有天，需要勤勤恳恳，踏踏实实地提升自己，某一天终会绽放光芒。最后，西安加油，山河无恙！","text":"​ 题目不算难，获得了证书但成绩不算好，密码学应该要ak的，还是不够专注吧，做一半就跑去看杂项了。学到很多东西，遇到了CTF拿到国奖和国际奖以及AI发paper、机器人竞赛国二的大大大大佬，也认识了初中就能参加春秋杯进前十的小可爱…人外有人，天外有天，需要勤勤恳恳，踏踏实实地提升自己，某一天终会绽放光芒。最后，西安加油，山河无恙！ Misc八卦迷宫：​ 走出迷宫只有一条路径，根据题目说的需要提交拼音，猜测只需要按照路径把路径上的卦象对应的汉字拼音依次输入即可。需要用cazy{}包裹。 西安加油wireshark打开附件，http过滤，找到状态码为200的包： 其中一个只有数字和大写字母，猜测为base32： 网站解密，给出了图片顺序，猜测和flag有关： 另一个包的数据段里面是base64先解密前面一段，发现有关键词PK，猜测是zip文件base64加密： 解密脚本如下： 12345678910111213import base64from io import BytesIOimage_64_encode = &quot;data:application/zip;base64,UEsDBBQAAAAAAA...&quot;starter = image_64_encode.find(&#x27;,&#x27;)zip_data = image_64_encode[starter+1:]file_data = bytes(zip_data, encoding=&quot;ascii&quot;)d=base64.b64decode(file_data)with open(&quot;zip_decode1.zip&quot;, &#x27;wb&#x27;) as f: f.write(d) 数据段太长了，简写了。 得到zip文件，解压发现是47张图，按照base32明文的提示进行编号，拼凑可得flag Cryptono_cry_no_can​ 类似于简单的多表替换，将flag的每一位依次与key进行异或加密（key重复几次），得到密文，根据前几位”cazy{“可先将key求出来，然后用key与密文异或解密，附脚本： 1234567891011121314b&#x27;&lt;pH\\x86\\x1a&amp;&quot;m\\xce\\x12\\x00pm\\x97U1uA\\xcf\\x0c:NP\\xcf\\x18~l&#x27;b&#x27;cazy&#123;&#x27;flag1 = &#x27;cazy&#123;&#x27;out = &#x27;&lt;pH\\x86\\x1a&amp;&quot;m\\xce\\x12\\x00pm\\x97U1uA\\xcf\\x0c:NP\\xcf\\x18~l&#x27;for i in range(5): print(ord(flag1[i])^ord(out[i]))list = [95,17,50,255,97]*5list = list+[95,17]s= &#x27;&#x27;for i in range(27): s=s+chr(ord(out[i])^list[i])print(s) cazy{y3_1s_a_h4nds0me_b0y!} no_can_no_bb​ 简单aes加密，自定义了填充算法pad，由于密钥key随机范围太小，仅在1到2的20次方之间，可以通过爆破密钥破解密码，得到flag，附脚本： 1234567891011121314from Crypto.Util.number import *from Crypto.Cipher import AESc = b&#x27;\\x9d\\x18K\\x84n\\xb8b|\\x18\\xad4\\xc6\\xfc\\xec\\xfe\\x14\\x0b_T\\xe3\\x1b\\x03Q\\x96e\\x9e\\xb8MQ\\xd5\\xc3\\x1c&#x27;def pad(m): tmp = 16-(len(m)%16) return m + bytes([tmp for _ in range(tmp)])for i in range(1&lt;&lt;20): key = pad(long_to_bytes(i)) aes = AES.new(key, AES.MODE_ECB) flag=aes.decrypt(c) if flag[0:5]== b&#x27;cazy&#123;&#x27;: print(flag) cazy{n0_c4n,bb?n0p3!} no_math_no_cry​ 赛后才想起来开平方有负根，这题白给了QAQ. 初中数学题，含开平方的计算，exp： 123456789from Crypto.Util.number import*import gmpy2num1 = 10715086071862673209484250490600018105614048117055336074437503883703510511248211671489145400471130049712947188505612184220711949974689275316345656079538583389095869818942817127245278601695124271626668045250476877726638182396614587807925457735428719972874944279172128411500209111406507112585996098530169num2 = num1 - 0x0338470num3 = gmpy2.iroot(num2,2)[0]m = -num3 + (1&lt;&lt;500)flag = str(long_to_bytes(m))print(flag) cazy{1234567890_no_m4th_n0_cRy} LinearEquations​ 这题也是白给，前几天正好学了LCG的攻击方式，已经推出递推关系了，当时忙着去拼杂项那题的flag没做下去。完整分析过程： exp： 1234567891011121314from Crypto.Util.number import *import gmpy2data = [2626199569775466793, 8922951687182166500, 454458498974504742, 7289424376539417914, 8673638837300855396]n = 10104483468358610819print(getRandomInteger(64))print(len(data))tmp = [0]for i in range(1,5): tmp.append(data[i] - data[i - 1])a = (tmp[2] * tmp[3] - tmp[1] * tmp[4]) * gmpy2.invert(tmp[2] * tmp[2] - tmp[1] * tmp[3],n) % nb = (tmp[3] - a * tmp[2]) * gmpy2.invert(tmp[1],n) % nc = (data[4] - a * data[3] - b * data[2]) % nprint(a,b,c)print(b&#x27;cazy&#123;&#x27; + long_to_bytes(a) + long_to_bytes(b) + long_to_bytes(c) + b&#x27;&#125;&#x27;) cazy{L1near_Equ4t1on6_1s_34sy} math​ 这道题应该算是最难的一道，也是唯一做不出来的，看了La大佬的unusualrsa学习解法： exp： 123456789101112131415161718192021222324252627from Crypto.Util.number import *import gmpy2from functools import *pinvq = 0x63367a2b947c21d5051144d2d40572e366e19e3539a3074a433a92161465543157854669134c03642a12d304d2d9036e6458fe4c850c772c19c4eb3f567902b3qinvp = 0x79388eb6c541fffefc9cfb083f3662655651502d81ccc00ecde17a75f316bc97a8d888286f21b1235bde1f35efe13f8b3edb739c8f28e6e6043cb29569aa0e7bc = 0x5a1e001edd22964dd501eac6071091027db7665e5355426e1fa0c6360accbc013c7a36da88797de1960a6e9f1cf9ad9b8fd837b76fea7e11eac30a898c7a8b6d8c8989db07c2d80b14487a167c0064442e1fb9fd657a519cac5651457d64223baa30d8b7689d22f5f3795659ba50fb808b1863b344d8a8753b60bb4188b5e386e = 0x10005d = 0xae285803302de933cfc181bd4b9ab2ae09d1991509cb165aa1650bef78a8b23548bb17175f10cddffcde1a1cf36417cc080a622a1f8c64deb6d16667851942375670c50c5a32796545784f0bbcfdf2c0629a3d4f8e1a8a683f2aa63971f8e126c2ef75e08f56d16e1ec492cf9d26e730eae4d1a3fecbbb5db81e74d5195f49f1for k in range(100000): if((e * d - 1) % (100000 - k) == 0): print(100000 - k) break# print(e)k = 60701phi = (e * d - 1) // kprint(phi)x = 1 + qinvp * phi - qinvptmp1 = pow(2,phi,x) - 1tmp2 = pow(3,phi,x) - 1tmp3 = pow(5,phi,x) - 1p = reduce(gmpy2.gcd,[tmp1,tmp2,tmp3])q = gmpy2.invert(qinvp,p)n = p * qm = pow(c,d,n)print(long_to_bytes(m)) flag{c4617a206ba83d7f824dc44e5e67196a}","categories":[{"name":"赛事","slug":"赛事","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/"},{"name":"长安战疫","slug":"赛事/长安战疫","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"赛事","slug":"赛事","permalink":"http://example.com/tags/%E8%B5%9B%E4%BA%8B/"},{"name":"misc","slug":"misc","permalink":"http://example.com/tags/misc/"}]},{"title":"Python数据结构—双端队列","slug":"Python数据结构—双端队列","date":"2022-01-06T05:17:21.000Z","updated":"2022-01-06T05:35:33.703Z","comments":true,"path":"2022/01/06/Python数据结构—双端队列/","link":"","permalink":"http://example.com/2022/01/06/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/","excerpt":"​ 双端队列是与队列类似的有序集合，它有前后两端，元素在其中保持自己的位置，并且可在任一端添加和移除元素，是一种更灵活的数据结构。","text":"​ 双端队列是与队列类似的有序集合，它有前后两端，元素在其中保持自己的位置，并且可在任一端添加和移除元素，是一种更灵活的数据结构。 12345678910111213141516171819202122232425262728293031323334353637383940# python实现双端队列class Deque: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] #规定队列前端为列表的右端 def addFront(self,item): self.items.append(item) def addRear(self,item): self.items.insert(0,item) def removeFront(self): return self.items.pop() def removeRear(self): return self.items.pop(0) def size(self): return len(self.items)# 双端队列应用：回文检测器&#x27;&#x27;&#x27;回文是指从左往右和从右往左读都一样的字符串，例如toot，radar。利用双端队列的特性，可以将字符串从队列后端压入，然后同时从前端、后端读取第i个字符，直到队列中所有字符被遍历（偶数个字符），或剩下最中间的一个字符。即实现了回文字符串的判定&#x27;&#x27;&#x27;def palchecker(String): chardeque = Deque() for ch in String: chardeque.addRear(ch) stillEqual = True while chardeque.size() &gt; 1 and stillEqual: first = chardeque.removeFront() last = chardeque.removeRear() if first != last: stillEqual = False return stillEqual","categories":[{"name":"python数据结构与算法","slug":"python数据结构与算法","permalink":"http://example.com/categories/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python数据结构","slug":"python数据结构","permalink":"http://example.com/tags/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"队列","slug":"队列","permalink":"http://example.com/tags/%E9%98%9F%E5%88%97/"}]},{"title":"RSA—DP泄露（一）","slug":"RSA—DP泄露","date":"2022-01-05T11:39:11.000Z","updated":"2022-02-17T02:35:45.488Z","comments":true,"path":"2022/01/05/RSA—DP泄露/","link":"","permalink":"http://example.com/2022/01/05/RSA%E2%80%94DP%E6%B3%84%E9%9C%B2/","excerpt":"​ dp就是私钥dmod（p-1)，即dp = d mod（p-1）。dp泄露的原理如下：","text":"​ dp就是私钥dmod（p-1)，即dp = d mod（p-1）。dp泄露的原理如下： ​ 由于得到了X的范围，可以遍历X （65537种可能），利用（p-1）为整数这一限制条件求出( p − 1 )，此时的p不一定正确，还需要验证是否为n的因数，如果是，则说明p无误。得到正确的p以后，可还原明文。 12345678for i in range(1,65538): if (dp*e-1)%i == 0: if n%(((dp*e-1)/i)+1)==0: p=((dp*e-1)/i)+1 q=n/(((dp*e-1)/i)+1) phi = (p-1)*(q-1) d = gmpy2.invert(e,phi)%phi ​ 示例： 12345e = 65537n = 156808343598578774957375696815188980682166740609302831099696492068246337198792510898818496239166339015207305102101431634283168544492984586566799996471150252382144148257236707247267506165670877506370253127695314163987084076462560095456635833650720606337852199362362120808707925913897956527780930423574343287847c = 108542078809057774666748066235473292495343753790443966020636060807418393737258696352569345621488958094856305865603100885838672591764072157183336139243588435583104423268921439473113244493821692560960443688048994557463526099985303667243623711454841573922233051289561865599722004107134302070301237345400354257869dp = 734763139918837027274765680404546851353356952885439663987181004382601658386317353877499122276686150509151221546249750373865024485652349719427182780275825 ​ 解密脚本： 12345678910111213141516171819import gmpy2from Crypto.Util.number import *e = 65537n = 156808343598578774957375696815188980682166740609302831099696492068246337198792510898818496239166339015207305102101431634283168544492984586566799996471150252382144148257236707247267506165670877506370253127695314163987084076462560095456635833650720606337852199362362120808707925913897956527780930423574343287847c = 108542078809057774666748066235473292495343753790443966020636060807418393737258696352569345621488958094856305865603100885838672591764072157183336139243588435583104423268921439473113244493821692560960443688048994557463526099985303667243623711454841573922233051289561865599722004107134302070301237345400354257869dp = 734763139918837027274765680404546851353356952885439663987181004382601658386317353877499122276686150509151221546249750373865024485652349719427182780275825for i in range(1,65538): if (dp*e-1)%i == 0: if n%(((dp*e-1)//i)+1)==0: p=((dp*e-1)//i)+1 print(p) q=n//(((dp*e-1)//i)+1) phi = (p-1)*(q-1) d = gmpy2.invert(e,phi)%phi print(d)m = pow(c,d,n)print(long_to_bytes(m)) wctf2020{dp_leaking_1s_very_d@angerous}","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"RSA","slug":"比赛/RSA","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/"},{"name":"数论或其它","slug":"比赛/RSA/数论或其它","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/%E6%95%B0%E8%AE%BA%E6%88%96%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"UNCTF2021-baby_rsa","slug":"UNCTF2021-baby-rsa","date":"2022-01-05T07:38:21.000Z","updated":"2022-02-09T14:10:10.311Z","comments":true,"path":"2022/01/05/UNCTF2021-baby-rsa/","link":"","permalink":"http://example.com/2022/01/05/UNCTF2021-baby-rsa/","excerpt":"​ 和室友一起参加了UNCTF2021，分别获得第二和第三；总的来说题目比较基础，AK了密码和杂项。只记录一道题。","text":"​ 和室友一起参加了UNCTF2021，分别获得第二和第三；总的来说题目比较基础，AK了密码和杂项。只记录一道题。 ​ 题目： 123456789101112131415161718import gmpy2import libnumimport randomimport uuidflag=&quot;unctf&#123;&quot;+str(uuid.uuid4())+&quot;&#125;&quot;m=libnum.s2n(flag)p=libnum.generate_prime(1024)q=libnum.generate_prime(1024)n=p*qe=65537c=pow(m*p+n,e,n)print(&quot;n=&quot;,n)print(&quot;c=&quot;,c)print(&quot;e=&quot;,e)#n= 27023180567533176673625876001733765250439008888496677405372613659387969480500400831799338479404533734632060401129194207025095826786316107611502577395964365591899893794206238112244571942694129959717225168573059987542436467778426312967832431595178558711258027999897974942046398583397445299861338203860420721585460676138091828032223153425728023656897880166788811969523526091221520293020106530587453637600349533427641518473788620430866128331962450325767202417824455886116760280239705754222948387172102353564657340216229891342124971948458724351338597649821310431397426705701275774039588035776573373417654649168810548916141#c= 3489599657527403893851973553294684608504140532554562294027722218597464669848608337663997115805201027340092733823019661706872544231209523772845492398492677185660213963118144668038183924970370481476141221609706208064428560732214361469135212057355342825193598971775551833240699393482839422273480793244841531126642199202744610656153155545415859410361595564197685655133074582118230993519133935533313364233668337427608419528430102794052261190930670933657287272452581248934890029409559234507626012423255430699687038808658327174609660874748540185589263800447650242593224189976058739054174360024536594384447518687126891675059#e= 65537 ​ 根据已知信息化简得到一个关系：c=pow（m*p，e，n），再根据这个关系可以推出p其实就是c和n的最大公因数，那么可以求出p从而得到q，d求出明文，脚本： 12345678910111213141516171819202122232425262728import gmpy2from Crypto.Util.number import *def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return a #辗转相除法n= 27023180567533176673625876001733765250439008888496677405372613659387969480500400831799338479404533734632060401129194207025095826786316107611502577395964365591899893794206238112244571942694129959717225168573059987542436467778426312967832431595178558711258027999897974942046398583397445299861338203860420721585460676138091828032223153425728023656897880166788811969523526091221520293020106530587453637600349533427641518473788620430866128331962450325767202417824455886116760280239705754222948387172102353564657340216229891342124971948458724351338597649821310431397426705701275774039588035776573373417654649168810548916141c= 3489599657527403893851973553294684608504140532554562294027722218597464669848608337663997115805201027340092733823019661706872544231209523772845492398492677185660213963118144668038183924970370481476141221609706208064428560732214361469135212057355342825193598971775551833240699393482839422273480793244841531126642199202744610656153155545415859410361595564197685655133074582118230993519133935533313364233668337427608419528430102794052261190930670933657287272452581248934890029409559234507626012423255430699687038808658327174609660874748540185589263800447650242593224189976058739054174360024536594384447518687126891675059e= 65537p=gcd(n,c)print(p)q=n//pprint(q)phi=(p-1)*(q-1)print(n==p*q)d=gmpy2.invert(e,phi)print(d)m0=pow(c,d,n)m=(m0)//pflag=long_to_bytes(m)print(flag)","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"RSA","slug":"比赛/RSA","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/"},{"name":"数论或其它","slug":"比赛/RSA/数论或其它","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/%E6%95%B0%E8%AE%BA%E6%88%96%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"Python数据结构—队列","slug":"Python数据结构—队列","date":"2022-01-04T10:30:01.000Z","updated":"2022-01-04T10:33:57.666Z","comments":true,"path":"2022/01/04/Python数据结构—队列/","link":"","permalink":"http://example.com/2022/01/04/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E9%98%9F%E5%88%97/","excerpt":"​ Python实现队列，以及两个应用：1.约瑟夫斯问题 2.打印机任务问题 队列在实际的开发编程和系统编程中用的非常多，以后还需要继续学习。","text":"​ Python实现队列，以及两个应用：1.约瑟夫斯问题 2.打印机任务问题 队列在实际的开发编程和系统编程中用的非常多，以后还需要继续学习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# python实现简单队列import randomclass Queue: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] #入队用insert,复杂度为O(n) def enqueue(self,item): self.items.insert(0,item) #出队列用pop,复杂度为O(1) def dequeue(self): return self.items.pop() def size(self): return len(self.items)# 队列应用一: 约瑟夫斯问题def hotPatato(namelist,num): simqueue = Queue() for name in namelist: simqueue.enqueue(name) while simqueue.size() &gt; 1: for i in range(num): simqueue.enqueue(simqueue.dequeue()) #入列和出列num次以后，队列头的名字出局 simqueue.dequeue() return simqueue.dequeue()# 队列应用二:打印任务class Printer:# 打印机类,用于初始化打印速度,判断打印机状态,打印工作计时等 def __init__(self,ppm): self.pagerate = ppm self.currentTask = None self.timeRemaining = 0 def tick(self): #打印工作计时器，调用一次只减一秒 if self.currentTask != None: self.timeRemaining = self.timeRemaining - 1 if self.timeRemaining &lt;= 0: self.currentTask = None def busy(self): #判断打印机当前是否被占用 if self.currentTask != None: return True else: return False def startNext(self,newtask): #新任务以及其工作所需打印时间 self.currentTask = newtask self.timeRemaining = newtask.getpage() * 60 /self.pagerateclass Task:# 任务类,每个新的打印任务的初始化设定,比如任务建立时的时间戳等 def __init__(self,time): self.timestamp = time self.pages = random.random(1,21) def getStamp(self): return self.timestamp def getPages(self): return self.pages # 等待时间为开始处理时的时间减去任务建立时的时间 def waitTime(self,currenttime): return currenttime - self.timestampdef simulation(numSeconds,pagesPerMin): labprinter = Printer(pagesPerMin) printQueue = Queue() waitingtimes = [] #用一个列表来保存每个任务的等待时间，最后汇总 for currentSecond in range(numSeconds): if newPrintTask(): task = Task() printQueue.enqueue(task) if (not labprinter.busy()) and (not printQueue.isEmpty()): nexttask = printQueue.dequeue() waitingtimes.append(nexttask.waitTime(currentSecond)) labprinter.startNext(nexttask) labprinter.tick()# 输出当前执行(过)的任务的平均等待时间和队列剩余的任务 averageWait = sum(waitingtimes)/len(waitingtimes) print(&quot;Average Wait %6.2f seconds %3d tasks remaining.&quot;%(averageWait,printQueue.size()))def newPrintTask(): num = random.randrange(1,181) if num == 180: return True else: return False","categories":[{"name":"python数据结构与算法","slug":"python数据结构与算法","permalink":"http://example.com/categories/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python数据结构","slug":"python数据结构","permalink":"http://example.com/tags/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"队列","slug":"队列","permalink":"http://example.com/tags/%E9%98%9F%E5%88%97/"}]},{"title":"CTFshow-大吉大利杯-easysignin","slug":"CTFshow-大吉大利杯-easysignin","date":"2022-01-03T07:06:46.000Z","updated":"2022-01-03T07:13:26.091Z","comments":true,"path":"2022/01/03/CTFshow-大吉大利杯-easysignin/","link":"","permalink":"http://example.com/2022/01/03/CTFshow-%E5%A4%A7%E5%90%89%E5%A4%A7%E5%88%A9%E6%9D%AF-easysignin/","excerpt":"​ 考察的是对LCG伪随机算法的攻击。","text":"​ 考察的是对LCG伪随机算法的攻击。 ​ 题目： 1234567891011121314151617181920212223242526272829from Crypto.Util.number import getPrime, isPrime, bytes_to_longfrom random import getrandbitsfrom secret import flagdef genpq(k): while True: p = getPrime((k + 3) // 4) q = getPrime((k + 3) // 4) if ((p ** 2) * (q ** 2)).bit_length() == k: return (p, q)def genseq(t, k): x = getrandbits(k) y = getrandbits(k) r = [] r += [pow(x * getrandbits(k)+y, pow(getrandbits(k), t - 1, t), t)] for i in range(len(flag)): r += [pow(x * r[i] +y, pow(getrandbits(k), t - 1, t), t)] return r(p, q) = genpq(2021)e = getPrime(0x0123)r = [genseq(p, p.bit_length() // 4), genseq(q, q.bit_length() // 4), genseq(e, e.bit_length() // 4)]c = pow(bytes_to_long(flag), e, 2021 * p * q)out = open(&#x27;output.txt&#x27;,&#x27;w&#x27;)out.write(str(r) + &quot;\\n&quot;)out.write(str(c) + &quot;\\n&quot;)out.close() ​ 其实就是RSA套上了LCG进行混淆，看起来复杂实际上考点就两个： 1.费马小定理：题中r += [pow(x * r[i] +y, pow(getrandbits(k), t - 1, t), t)] 这里指数部分可化简为1 2.对LCG算法的破解： 12345def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return crack_unknown_multiplier(states, modulus) 完整脚本： 1234567891011121314151617181920212223242526272829303132333435363738import numpy as npfrom functools import reducefrom math import gcdfrom gmpy2 import *output = [[52410740454341322584968668119249347590637310744053575667199658377254616720, 645233054655774190743329734650633925675658559407235845892000719418629264735950925156778060047916782135118939609, 7943518660704895786672594284269647711181509726633514226380530196425485458539625694575495231887385619012015881286882728587606040595061922764546504652, 88914058098690563261741069739196350367736459872642989654182096322219071679192700322294625591039910568014594162793682719562807511893126265269018965631844, 21848556616661858554457567702772141873495700440964466396641152668611914726571047215318351614761015187840557741595013435098462212054082613351365353879971, 30981990147740324963531127581242040452010812929397936350977330949621677682914852118175610889739709323337510806201042485424717012639070029274069982697770, 86391152218016366813847004247404056131417771687236374092616383814217301192122912423701248555978593644222324385731750478659656390099667206731986826034783, 11919788822817325862607995189694676040563253448913899451812469694262245578863190210002110273555634880385761984875510033893001873388959689185144905903209, 113172562380439676720883790279148843121957456418188815624366983390069987176782078966213846939157552371083567965339468376209438408527447055279432563530293, 53639431322349477360106465790490257401135940987536122273392905439789302677727263369595453217090741732679101465032774237786279512056854438308525173657159, 66494591146164538399359207417261107297618965139951036147349388185500471848417939882942051000401169375606555137676945793825997569250321049050064328504686, 68140755777619578564543055029117317295128399240486821374257706188512954130154120098052147911199011456619478205381967508904616755976025013771737828736712, 108937156773321279370931816069281780172829105656866216917516598661018254865761711673453882295854673659374303771527203182421483883387191105457655039518598, 23851657909638071121522950452985193121203677553882352681904178324157544934072951198267420469049884225406011127813710965228771378971223671119499320807527, 73593420351924535735583383759106213752911143688405196033083181161847427289244164307112764704106027032275168673202117613094614344445994185733167048206528, 45149231454111577928491035214773110610124553323394642764742046515465337002110008680672172596244297975180829797354612671475605687567668633260989146225109, 116595530380208734174324933018691232247236449545224536610877958513488572395417607779848679300427540247845082936159111075084099286531721388893818985053741, 19184570673197822395630076591747812314740067696017031829688067440093395269633819900129824384419564803863978782409207577313654883568996185370309615089861, 25053641421607032412936267237167725716755999385160231284419862285097826856694410270421890957270689086653085525341558101625176940863016775431803134278503, 41834644301798766586022917842507064432100240754373142283841634039601045968196848660974947416021443814036134492045552003431910969249042558378746090903740, 42360644234440625880638052651286919014389438067342750959116570502193321560916125003972414759569882508574236473191565962375571182326447121493190045921270, 64154129476091746233508446729279257596903523952542574303253450285299398583980541526259161563202739149004027272968609086796202499698823078817922156242997, 99743770056582602741303337738692194013086027384260039696324929460010638859447328004451799213553786836333122482774819971466325395235923612135604232226628, 76016751544879152402468315780586583194677362762856804802274327372452749909986720770385321555358806909857936245178757512784557916380481731086991902054287, 15290970738221187280390322268161848800499662337983876912254205399494853703975899722962615773380166218671937854689533200852650284347709468624816742506301, 67706974286610751556509787688743881517790029217389913481852566524040229236517365403017047098395951124264255110450504690606926248507428249271556983456901, 93639585966460526678788701909900876014525038540391772469992121354765056693895744954209300307081001946602586071602887248893957063725982565677570972746179, 116294621911461475477765026959041413149677852360214402280735648748333959155194969755168263936256009261138274595240480200664019902568187683340477743969899, 5600077388578735042597674074656979994549617482972881863164687525745536334190390401329680675467385619222535929475803379568900871335069384301033734714233, 14950370510302209746655108744292059719774565235701177358607157704462080787582712898381047410531181256769171281519411806803555715962755361346294970645323, 62016127245313515166454506817734613861723408949410899879216139989641932810248154680978274902855232651990299832297039642288310178403863342787840550299197, 95333439043968773649754476810195845118762991943266271403726184079242047672417932848967803488781971181275041399864016152589549446967782464066482170680045, 17892190659451591126424119305367671928739240611597727166543577571172322192576331228580357825811249660239169745390013910560069896203797045063231158722853, 47343585379646662714119978325645155712476914243757156114505021559030784519828048323795389199684946739451189942398561417829509539613791387644014640880892, 107633502313698058424938275622569640009485699854002361851653372416279664993830018051561865544743074946977906999458321566411251984151075748983779536801656, 101301834848265959280691115298109056299094420476120335636075492785328213139655230146061664228486248771534280699591814762729915638378841230330876525933001, 100833383873897711880618620396289395792480753105857884143070890861779172346713570088651208648247678032376842604846315923312830531728252064463150986767877, 110832079086180425600051267498601847526388754584982689270788472799404147017261513262539159424820032777910677631796771424828022748042489660903717952947232], [2447835208216480089797117166098772864739983439147154550843410133502162338263, 90343453249141616309012786446354427397838634661038147051928857871447909510509540184081882802706067411363905232391, 3334350089247517867244794106926436317086273858623518082485947115508154733111001565093191192674670220618972600184165291699923904558749567306156634412295, 10773127238350735566139610265473489634284355749344684347913928639165091011956627111779426812064973544315989779523475733083567151499479793829671206141097, 106073688178033729190829682109679728245170052489478284990130508152039157863313154674078420619615011691032124222115566415769268517103742200043347846746310, 96864656966701608190452551924897023075560536848477610188768188296307194880004203630087264191421619540332532988322143583373922117130397679868254621842062, 90007570555125944092169218313738703993888121021783637142913909308099775085919518984873236408360228986382651525244328621860786089655176559888337945973265, 107604402646950221603694740182904829452610405361494187112972298194020162739490546852179057650360974702490340526819923399009740841491688354483369514169504, 106563280130150122326814032245025170948640642468357539265829858841580809022713867834571254297385660279367044782111285768058114284965175416454533853149098, 34006794372719255946701440846013876868985083446980545795344603308580913114300387951211231095472417358606631528579058832071833342645392417576288348171281, 80528690688989385531407273709213599547356208780618772147048236656262530606555256335153687882045380456243914208416285214393577589279953053395148801048043, 25252035922809872666372710839612084651799975462368368568421254228924839144802392424596779526739759011515745889793921767279843129898429087648706961214380, 15441075054379206603678761656461990005728026633190896788589499872488783507420374230165723864117983219469482787021780166107230849440690930291658692943884, 15730255840343160294128109470006774677678596243801516284827627241776907423825237162176372972699529694206547624329200148008905292241372763696643556851248, 15929374919958330762187534489183857327423262543417435665674052288372574077203981789863180537536922526152815069819616552018951188431418135256962942313150, 16820416513541190327907989962230541088691747266081952862738221010557935254064045592670849585275377539144509827653431170474288972399346359112627171936199, 62613123636486933874885881624168137103745407796444871779926315982802027799075166745074790838012194635812853433064138182942124531618582978708688026203712, 103390317097626211538390057925702534478424865400956004756449501914108837524902468766472576617059468680745338232757547345497585919880616072977553233278603, 106855090961917607608766903030826427305834559006355051082927925151921938627824191628649167300491312597092422279212561689251186535550087727802277317012637, 78550566353218314794723213322674271780550941969941432645092204751089489784529040122660556916516795686398814802277195824477145440164288404226182667432413, 27234374989834250512863591479223580820709377656219659243546791666422683600672138485672126972130292224970890443705416445427654052263167668188984214509496, 89073500384217027637576686609574923520864474465437796981228200517382920934009159891695058762467754821583073917774195612915842601271956467375250874741115, 81523221328096138331223676561475793372150203835133425580501094268867250067873677785078977441798107146380161414152017043957710432372886446496269471249870, 69426635873092086451473939772373894337793035157602866886753621226137855012060402481656332348663588598120734258884064385818693263157949512108768237653037, 27038496127031393485308453098136903958592822859537990682349040311778748501331008447014951690343425476063063582655448477055880499291781315998134395062551, 86563190395140161836966058609094941013946825669471943800850341447296711952143605563471041765702929391516506170236643633037511742900440430412347138373811, 92654519757605791295431607106260304699360787251056766515059747102627521170620749248095214607497002308663852187075958446074495640666063038994344066529674, 47978472743885278893083282341878167737725647616340703972452890584651298269018115725710882998002541867355534242320731285507237225498136712897684035221694, 33937234952409141712999986890445630797610786424992916483378338039398873916932446399890479122582956874435985731634172335771866950539140459057793782237502, 53536716653947884337358943672946218345105772801556349741322007215929226375220858833185514799016429985979192211191664179249403984470298515297769983151764, 15571885519410418984279068975979417469158262995629377377010899727496518373589643663028156863791907436837054446354508286361951842342722672331011023846114, 8566869430523038374329005968331909880668039196226700509945801110864252361948997146164771896223981284735805514278445995598366675322977971551419425480644, 87201260842977762054169640055047984836895338107976452298751798557901196013452620843946503586203236027871183035720513488012632267170999498276073312805571, 93478630791498129840635935563160804999341438068212212075961484875554801063436616116564312106399142481823172612186464441144737797880760682581757444561694, 49399628737188601660367894914908547591976252279392032109588827791264737386179351022649986152248431169393115396754709411287013944596327999564120047443685, 401770084546389936795883960043586247087806968600408302529922285961914019164988332998528995717095956973083747814499516267750284263835592854038001543364, 46910295459783203906544465622227903475837618852453968036856768892034422511892075866806031498301570602549864578109096480551648362399275135770250479266764, 48705341969973174964195737555908215932127208480896065769947732952516004887948769345944422825151845846335939723147282687407339303320406462649862333812892], [6763996718934951285742307562806923397006813, 12234833447991510153841494781985313133191586854789667980564533023, 22130576894138701986742918639431233979778270965194566122306861346111716828577556403873, 767648503612570945278792619619046535101078814202096337589566648572901378566441587067065, 1534503080514914991237881845264698854398689474324594013087679222396116209460382272347120, 2150152040945137216175051477345156832872965887696888090617763887196376039836211151684155, 1519134084444926105081859598135660300537196230332783741163873836023160842189452416751204, 1347961026269871555909121507968616952100851882185690586872363417766328195659354367286160, 442978203022900661788725058674237344919172289937224290573991574448751808619506704123728, 434277065671750016380827889451816552550232352950909430034013985469154609260218730764780, 979776898630843046146074197140740184861751729514455753655622904091278621814340310325052, 873700620112565719323179396419879070723310944684570011051348198205453537590517739575294, 1256514485942478003559638390025523283241250878990443282316967845337571713994674756627249, 2201413023234946734277012190477530998161056783942361564091571454780425152722167887757333, 15845440233510397242131879469914499447138153273633842521183302623397377025857347058355, 719557135712047144341175773587928323041035301800224566640992208827132114843710118060603, 1872194680805780497350808471632655890088399919927439303351392835028632946050942049128363, 739802156645251387441611149162232326760167809822024988834688224156162966157182526727210, 1842345264759627182982545223023325564813297247358347573262929227611626782102112032498792, 1942056684591589139535850561429570147021382203103121319949566652649463471174580278445972, 1897401671012077468168242201956275317342401618250346254943410859299471001683176665446266, 1299697210304599531296837763293611409445703982993464696432211710136915756408352763838420, 6339661487999740913576932261380541287960678716377148820725064627689077214923145744267, 206550580254594047163709231196572177167911612047377521986355302588778287613331054094422, 2095017194382050543451996020322766986862239168048229828922060511851698524762340797229358, 38154091093834482476428418031816301638508654861013053691521551593888386192530215738249, 2312527000380201589293545236295238368648424299462645212556813668113451665892155924195549, 1148055457422644367319939159612923263814575289811148258779972071041630980150900639103033, 2491032359438353539795070569649180009224077260857699946936305612971624383446047213147218, 2502865604540348808929226301472051722005592649019284150593000357524824393775392671519130, 1039938101331801857780518763744667966269026413223284682004343257200589049680488254035897, 316947919834210211954441725158411391798247265696200080865972078867990121934703299224598, 1191200775168680784071665067183230700343262160056248368421562785231813797955113569864397, 517875043776615303660143356495634794257910735766828738806709874383193521216795724710570, 177783588672600341630231835251624651899982858825356048074013206591129692021093027549523, 1181655045918151017173609506041984644632154476633196738728202200703641104893529622554198, 1943728872455114467893276648701066972260927692980375525686315254866764954534482612584812, 841323196734187035327534237852681191366390226431490238525430672327199713070166890155539]]output = np.array(output)def crack_unknown_increment(states, modulus, multiplier): increment = (states[1] - states[0]*multiplier) % modulus return modulus, multiplier, incrementdef crack_unknown_multiplier(states, modulus): multiplier = (states[2] - states[1]) * invert(states[1] - states[0], modulus) % modulus return crack_unknown_increment(states, modulus, multiplier)def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return crack_unknown_multiplier(states, modulus)rp = output[0]rq = output[1]re = output[2]c = 1499341850116033218583322015832654376326982200720069022052964940686970117688218295301399005244875933100636608594036976589026918517646244220826168516373612155557984806411945784862108964553911520434368098212111129654894447128360717210621466898152738161667124194644244479881039031313468828783882375812512993823xp, yp, p = crack_unknown_modulus(rp)xq, yq, q = crack_unknown_modulus(rq)xe, ye, e = crack_unknown_modulus(re)print(p)print(q)print(e)for i in (0,pow(2,1000)): if pow(i,e,2021*p*q) == c: print(i)","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"}]},{"title":"线性同余生成器（LCG）-原理及攻击方式（一）","slug":"线性同余生成器（LCG）-原理及攻击方式（一）","date":"2021-12-30T10:04:56.000Z","updated":"2022-02-10T14:08:36.154Z","comments":true,"path":"2021/12/30/线性同余生成器（LCG）-原理及攻击方式（一）/","link":"","permalink":"http://example.com/2021/12/30/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%88LCG%EF%BC%89-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"​ 线性同余方法（LCG）是个产生伪随机数的方法。 它是根据递归公式：Sn+1 = (A*Sn + B) mod M 进行实现， 其中A,B,M是产生器设定的常数。我们常说的种子数seed其实就是初始的S0的值。","text":"​ 线性同余方法（LCG）是个产生伪随机数的方法。 它是根据递归公式：Sn+1 = (A*Sn + B) mod M 进行实现， 其中A,B,M是产生器设定的常数。我们常说的种子数seed其实就是初始的S0的值。 实现算法： 12345678910111213141516class prng_lcg: m = 672257317069504227 # &quot;乘数&quot; c = 7382843889490547368 # &quot;增量&quot; n = 9223372036854775783 # &quot;模数&quot; def __init__(self, seed): self.state = seed # the &quot;seed&quot; def next(self): self.state = (self.state * self.m + self.c) % self.n return self.state def test(): gen = prng_lcg(123) # seed = 123 print gen.next() # 第一个生成值 print gen.next() # 第二个生成值 print gen.next() # 第三个生成值 基本攻击方式有四种，基本都基于初等数学计算方法，还有基于格理论的攻击方法以后再更新。 1.对于A、B、M以及N0已知的情况假设我们观察到有一个LCG系统产生了以下三组连续的值，并且知道内部的参数如下: 12345678# 三组连续的值s0 = 2300417199649672133s1 = 2071270403368304644s2 = 5907618127072939765# 内部的参数m = 672257317069504227 # the &quot;multiplier&quot;c = 7382843889490547368 # the &quot;increment&quot;n = 9223372036854775783 # the &quot;modulus&quot; 在已知了这些参数之后可以通过递推关系很快推算出未来的数值或者之前的某个数值。 2.增量未知不清楚增量，但是知道以下信息: 123456m = 81853448938945944c = # unknownn = 9223372036854775783# 初值和第一个计算值s0 = 4501678582054734753s1 = 4371244338968431602 稍稍改写下公式就可以将目标c计算出来 123s1 = s0*m + c (mod n)c = s1 - s0*m (mod n) 3.增量和乘数都未知虽然不知道增量和乘数但是知道以下数值： 1234567m = # unknownc = # unknownn = 9223372036854775783# LCG生成的初值和后面生成的两个值s0 = 6473702802409947663s1 = 6562621845583276653s2 = 4483807506768649573 解决办法很简单，想想怎么解线性方程组就好了 123456s_1 = s0*m + c (mod n)s_2 = s1*m + c (mod n)s_2 - s_1 = s1*m - s0*m (mod n)s_2 - s_1 = m*(s1 - s0) (mod n)m = (s_2 - s_1)/(s_1 - s_0) (mod n) 4.增量、乘数和模数均未知现在内部状态基本是都不知道了，但是知道初值和随后LCG产生的连续的几个值。 12345678910m = # unknownc = # unknownn = # unknowns0 = 2818206783446335158s1 = 3026581076925130250s2 = 136214319011561377s3 = 359019108775045580s4 = 2386075359657550866s5 = 1705259547463444505s6 = 2102452637059633432 用线性方程式无法解决了，因为未知数太多，引入多个随机数值都会给每个方程引入新的未知量： 123456s1 = s0*m + c (mod n)s2 = s1*m + c (mod n)s3 = s2*m + c (mod n)s1 - (s0*m + c) = k_1 * ns2 - (s1*m + c) = k_2 * ns3 - (s2*m + c) = k_3 * n 这就相当于六个未知数和三个方程，线性方程组不可能行得通。考虑利用gcd: 如果有几个随机数分别乘以n，那么这几个数的欧几里德算法(gcd)就很可能等于n。 123In [944]: n = 123456789In [945]: reduce(gcd, [randint(1, 1000000)*n, randint(1, 1000000)*n, randint(1, 1000000)*n])Out[945]: 123456789 某些非0值取模运算是会等于0的： 1X = 0 (mod n) 然后，根据定义，这相当于： 1X = k*n 这种X != 0但是X = 0 (mod n)的情况可以加以利用。我们只需要取几个这样的值进行gcd运算，我们就可以解出n的值。这是在模数未知的情况下十分常用的方法。 在此引入一个序列 – T(n) = S(n+1) - S(n): 1234t0 = s1 - s0t1 = s2 - s1 = (s1*m + c) - (s0*m + c) = m*(s1 - s0) = m*t0 (mod n)t2 = s3 - s2 = (s2*m + c) - (s1*m + c) = m*(s2 - s1) = m*t1 (mod n)t3 = s4 - s3 = (s3*m + c) - (s2*m + c) = m*(s3 - s2) = m*t2 (mod n) 之后就可以得到想要的效果了: 1t2*t0 - t1*t1 = (m*m*t0 * t0) - (m*t0 * m*t0) = 0 (mod n) 可以生成几个这样模是0的随机数算式，进而利用上文讲述的技巧。","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"伪随机数生成器","slug":"比赛/伪随机数生成器","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"LCG","slug":"比赛/伪随机数生成器/LCG","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LCG/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"PRNG","slug":"PRNG","permalink":"http://example.com/tags/PRNG/"},{"name":"LCG","slug":"LCG","permalink":"http://example.com/tags/LCG/"}]},{"title":"CTFshow-ROARCTF-EASYRSA","slug":"CTFshow-ROARCTF-EASYRSA","date":"2021-12-30T04:49:22.000Z","updated":"2021-12-30T04:58:50.619Z","comments":true,"path":"2021/12/30/CTFshow-ROARCTF-EASYRSA/","link":"","permalink":"http://example.com/2021/12/30/CTFshow-ROARCTF-EASYRSA/","excerpt":"​ 思路就是根据p、q的等式关系进行模变换计算得到（p-1）*（q-1），从而得到d破解密文。","text":"​ 思路就是根据p、q的等式关系进行模变换计算得到（p-1）*（q-1），从而得到d破解密文。 ​ 题目： 123456789101112131415161718192021222324from Crypto.Util.number import *from gmpy2 import *from secret import *assert(flag.startwith(&#x27;flag&#123;&#x27;)) and (flag.endwith(&#x27;&#125;&#x27;))assert(，(beta) and len(bin(beta)[2:]) == 512) assert(len(bin(x)[2:]) == len(bin(y)[2:]))# This is tip!!!assert(tip == 2*x*y*beta + x + y)p = 2*x*beta + 1q = 2*y*beta + 1assert(is_prime(p) and is_prime(q))n = p*qe = 65537m = bytes_to_long(flag)enc = powmod(m,e,n)#n=17986052241518124152579698727005505088573670763293762110375836247355612011054569717338676781772224186355540833136105641118789391002684013237464006860953174190278718294774874590936823847040556879723368745745863499521381501281961534965719063185861101706333863256855553691578381034302217163536137697146370869852180388385732050177505306982196493799420954022912860262710497234529008765582379823928557307038782793649826879316617865012433973899266322533955187594070215597700782682186705964842947435512183808651329554499897644733096933800570431036589775974437965028894251544530715336418443795864241340792616415926241778326529055663#e=65537#enc=10760807485718247466823893305767047250503197383143218026814141719093776781403513881079114556890534223832352132446445237573389249010880862460738448945011264928270648357652595432015646424427464523486856294998582949173459779764873664665361437483861277508734208729366952221351049574873831620714889674755106545281174797387906705765430764314845841490492038801926675266705606453163826755694482549401843247482172026764635778484644547733877083368527255145572732954216461334217963127783632702980064435718785556011795841651015143521512315148320334442235923393757396733821710592667519724592789856065414299022191871582955584644441117223#beta=11864389277042761216996641604675717452843530574016671576684180662096506094587545173005905433938758559675517932481818900399893444422743930613073261450555599 ​ 数学变换过程： ​ 题解： 12345678910111213141516171819202122232425from gmpy2 import *from Crypto.Util.number import *beta = 11864389277042761216996641604675717452843530574016671576684180662096506094587545173005905433938758559675517932481818900399893444422743930613073261450555599enc = 10760807485718247466823893305767047250503197383143218026814141719093776781403513881079114556890534223832352132446445237573389249010880862460738448945011264928270648357652595432015646424427464523486856294998582949173459779764873664665361437483861277508734208729366952221351049574873831620714889674755106545281174797387906705765430764314845841490492038801926675266705606453163826755694482549401843247482172026764635778484644547733877083368527255145572732954216461334217963127783632702980064435718785556011795841651015143521512315148320334442235923393757396733821710592667519724592789856065414299022191871582955584644441117223e = 65537n = 17986052241518124152579698727005505088573670763293762110375836247355612011054569717338676781772224186355540833136105641118789391002684013237464006860953174190278718294774874590936823847040556879723368745745863499521381501281961534965719063185861101706333863256855553691578381034302217163536137697146370869852180388385732050177505306982196493799420954022912860262710497234529008765582379823928557307038782793649826879316617865012433973899266322533955187594070215597700782682186705964842947435512183808651329554499897644733096933800570431036589775974437965028894251544530715336418443795864241340792616415926241778326529055663tip = (n - 1) // (2 * beta)answer = tip - tip % betadef solve(c1): pq1 = (answer - c1 * beta) * 2 * beta d = invert(e, pq1) flag = powmod(enc, d, n) flag = int(flag) flag = long_to_bytes(flag) if b&#x27;flag&#x27; in flag: print(flag) exit()for a1 in range(100, 1 &lt;&lt; 12): solve(a1) flag{21824349-25bb-4f7f-b551-f13d4abba2e2}","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"}]},{"title":"Python数据结构—栈","slug":"Python数据结构—栈","date":"2021-12-29T14:03:57.000Z","updated":"2021-12-29T14:07:46.690Z","comments":true,"path":"2021/12/29/Python数据结构—栈/","link":"","permalink":"http://example.com/2021/12/29/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E6%A0%88/","excerpt":"​ 摸鱼ing… python栈基本实现和简单实例。","text":"​ 摸鱼ing… python栈基本实现和简单实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131# python数据结构第一课 栈 2021/12/29import stringclass Stack: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] # 入栈 def push(self,item): self.items.append(item) # pop移除栈顶端的元素，并返回值 def pop(self): return self.items.pop() # peek返回栈顶端元素但不移除 def peek(self): return self.items[len(self.items)-1] def size(self): return len(self.items)def test(): s = Stack() print(s.isEmpty()) s.push(&#x27;cy&#x27;) s.push(&#x27;lzh&#x27;) s.push(1) s.push(&#123;&#x27;f&#x27;:&#x27;99&#x27;&#125;) print(s.isEmpty()) print(s.pop()) print(s.peek()) #不移除栈顶端的元素 print(s.size())# 栈的应用一:简单括号匹配def parChecker1(symbolString): s = Stack() balanced = True index = 0 while index &lt; len(symbolString) and balanced: symbol = symbolString(index) if symbol == &#x27;(&#x27; : #遇到左括号就入栈 s.push(symbol) else: if s.isEmpty(): balanced = False else: s.pop() #匹配到右括号就将栈里的左括号出栈 index = index + 1 if balanced and s.isEmpty(): return True else: return False# 栈的应用二:复杂括号匹配def matches(open,close): opens = &quot;([&#123;&quot; closes = &quot;)]&#125;&quot; return opens.index(open) == closes.index(close)#应该是最简单的写法吧？def parChecker2(symbolString): s = Stack() balanced = True index = 0 while index &lt; len(symbolString) and balanced: symbol = symbolString(index) if symbol in &quot;(&#123;[&quot;: s.push(symbol) else: if s.isEmpty(): balanced = False else: top = s.pop() if not matches(top,symbol): balanced = False index = index + 1 if balanced and s.isEmpty(): return True else: return False# 栈的应用三:十进制数转二进制（除k取余法,k也可以取其他值，可将十进制转化为其他非二进制数）def divideBy2(decNumber): remstack = Stack() while decNumber &gt; 0: rem = decNumber % 2 remstack.push(rem) decNumber = decNumber // 2 binString = &#x27;&#x27; while not remstack.isEmpty(): binString = binString + str(remstack.pop()) return binString# 栈的应用四:中序表达式到后序表达式的转化def infixToPostfix(infixexpr): prec = &#123;&#125; #用字典将数字和运算符号对应以确定运算符的优先级 prec[&quot;*&quot;] = 3 prec[&quot;/&quot;] = 3 prec[&quot;+&quot;] = 2 prec[&quot;-&quot;] = 2 prec[&quot;(&quot;] = 1 opStack = Stack() postfixList = [] tokenList = infixexpr.split() for token in tokenList: if token in string.ascii_uppercase: postfixList.append(token) elif token == &quot;(&quot;: opStack.push(token) elif token == &quot;)&quot;: topToken = opStack.pop() while topToken != &quot;(&quot;: postfixList.append(topToken) topToken = opStack.pop() else: while (not opStack.isEmpty()) and (prec[opStack.peek()] &gt;= prec[token]): postfixList.append(opStack.pop()) opStack.push(token) while not opStack.isEmpty(): postfixList.append(opStack.pop()) return &quot; &quot;.join(postfixList)","categories":[{"name":"python数据结构与算法","slug":"python数据结构与算法","permalink":"http://example.com/categories/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python数据结构","slug":"python数据结构","permalink":"http://example.com/tags/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"}]},{"title":"CTFshow-BJDCTF2020-六十四卦","slug":"CTFshow-BJDCTF2020-六十四卦","date":"2021-12-16T11:59:19.000Z","updated":"2021-12-16T12:38:38.171Z","comments":true,"path":"2021/12/16/CTFshow-BJDCTF2020-六十四卦/","link":"","permalink":"http://example.com/2021/12/16/CTFshow-BJDCTF2020-%E5%85%AD%E5%8D%81%E5%9B%9B%E5%8D%A6/","excerpt":"附件就两个，一个txt和一个py：","text":"附件就两个，一个txt和一个py： 根据题目和附件一的64卦，猜测和base64有关（不确定，无所谓），百度了一下64卦，感觉和卦象歌序关系不大，但是找到这张图，这他喵怎么越看越像01序列： 64卦，刚好6位01序列，先转化为01再转化为字符： 123456789101112131415161718192021s=&#x27;升随临损巽睽颐萃小过讼艮颐小过震蛊屯未济中孚艮困恒晋升损蛊萃蛊未济巽解艮贲未济观豫损蛊晋噬嗑晋旅解大畜困未济随蒙升解睽未济井困未济旅萃未济震蒙未济师涣归妹大有&#x27;dic=&#123;&#x27;坤&#x27;: &#x27;000000&#x27;, &#x27;剥&#x27;: &#x27;000001&#x27;, &#x27;比&#x27;: &#x27;000010&#x27;, &#x27;观&#x27;: &#x27;000011&#x27;, &#x27;豫&#x27;: &#x27;000100&#x27;, &#x27;晋&#x27;: &#x27;000101&#x27;, &#x27;萃&#x27;: &#x27;000110&#x27;, &#x27;否&#x27;: &#x27;000111&#x27;, &#x27;谦&#x27;: &#x27;001000&#x27;, &#x27;艮&#x27;: &#x27;001001&#x27;, &#x27;蹇&#x27;: &#x27;001010&#x27;, &#x27;渐&#x27;: &#x27;001011&#x27;, &#x27;小过&#x27;: &#x27;001100&#x27;, &#x27;旅&#x27;: &#x27;001101&#x27;, &#x27;咸&#x27;: &#x27;001110&#x27;, &#x27;遁&#x27;: &#x27;001111&#x27;, &#x27;师&#x27;: &#x27;010000&#x27;, &#x27;蒙&#x27;: &#x27;010001&#x27;, &#x27;坎&#x27;: &#x27;010010&#x27;, &#x27;涣&#x27;: &#x27;010011&#x27;, &#x27;解&#x27;: &#x27;010100&#x27;, &#x27;未济&#x27;: &#x27;010101&#x27;, &#x27;困&#x27;: &#x27;010110&#x27;, &#x27;讼&#x27;: &#x27;010111&#x27;, &#x27;升&#x27;: &#x27;011000&#x27;, &#x27;蛊&#x27;: &#x27;011001&#x27;, &#x27;井&#x27;: &#x27;011010&#x27;, &#x27;巽&#x27;: &#x27;011011&#x27;, &#x27;恒&#x27;: &#x27;011100&#x27;, &#x27;鼎&#x27;: &#x27;011101&#x27;, &#x27;大过&#x27;: &#x27;011110&#x27;, &#x27;姤&#x27;: &#x27;011111&#x27;, &#x27;复&#x27;: &#x27;100000&#x27;, &#x27;颐&#x27;: &#x27;100001&#x27;, &#x27;屯&#x27;: &#x27;100010&#x27;, &#x27;益&#x27;: &#x27;100011&#x27;, &#x27;震&#x27;: &#x27;100100&#x27;, &#x27;噬嗑&#x27;: &#x27;100101&#x27;, &#x27;随&#x27;: &#x27;100110&#x27;, &#x27;无妄&#x27;: &#x27;100111&#x27;, &#x27;明夷&#x27;: &#x27;101000&#x27;, &#x27;贲&#x27;: &#x27;101001&#x27;, &#x27;既济&#x27;: &#x27;101010&#x27;, &#x27;家人&#x27;: &#x27;101011&#x27;, &#x27;丰&#x27;: &#x27;101100&#x27;, &#x27;离&#x27;: &#x27;101101&#x27;, &#x27;革&#x27;: &#x27;101110&#x27;, &#x27;同人&#x27;: &#x27;101111&#x27;, &#x27;临&#x27;: &#x27;110000&#x27;, &#x27;损&#x27;: &#x27;110001&#x27;, &#x27;节&#x27;: &#x27;110010&#x27;, &#x27;中孚&#x27;: &#x27;110011&#x27;, &#x27;归妹&#x27;: &#x27;110100&#x27;, &#x27;睽&#x27;: &#x27;110101&#x27;, &#x27;兑&#x27;: &#x27;110110&#x27;, &#x27;履&#x27;: &#x27;110111&#x27;, &#x27;泰&#x27;: &#x27;111000&#x27;, &#x27;大畜&#x27;: &#x27;111001&#x27;, &#x27;需&#x27;: &#x27;111010&#x27;, &#x27;小畜&#x27;: &#x27;111011&#x27;, &#x27;大壮&#x27;: &#x27;111100&#x27;, &#x27;大有&#x27;: &#x27;111101&#x27;, &#x27;夬&#x27;: &#x27;111110&#x27;, &#x27;乾&#x27;: &#x27;111111&#x27;&#125;li=[]k=0for i in range(len(s)): if k ==1: k=0 continue try: li.append(dic[s[i]]) except: t=&#x27;&#x27; t=t+s[i]+s[i+1] li.append(dic[t]) k=1ss=&#x27;&#x27;.join(li)print(ss)enc=&#x27;&#x27;for i in range(0,len(ss),8): enc+=chr(eval(&#x27;0b&#x27;+ss[i:i+8]))print(enc) 输出 bl1oXF1ra2FbW2VpV1dfUmBiT11dYE5NVVdXSUZYSFVDUA== ；显然的base64，解密转成字节流： n]h]kka[[eiWW_RbO]]NMUWWIFXHUCP 这里别忘了还有一个py文件，也就是把flag的ASCII码进行了两次移位等操作；理一理顺序吧：flag -&gt;encrypt5 -&gt;encrypt4 -&gt;”算卦“ 所以我们解出base64以后，应该进行两次encrypt4，5的逆运算： encrypt4很简单： 123456def decrypt4(enc): temp=&#x27;&#x27; offset=5 for i in range(len(enc)): temp+=chr(ord(enc[i])+offset+i) return temp encrypt5有一丢丢的数论模运算： 123456789101112131415def decrypt4(enc): temp=&#x27;&#x27; offset=5 for i in range(len(enc)): temp+=chr(ord(enc[i])+offset+i) return tempdef decrypt5(flag): for a in range(1,100): enc = &#x27;&#x27; for i in flag: for k in range(200): if (ord(i) - 97 - 7+26*k)%a==0: enc+= chr((ord(i) - 97 - 7 + 26 * k) // a + 97) break print(enc) 最后得到的flag： bjdcongratulationsongettingtheflag 显然，出题人没丁丁QAQ","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"}]},{"title":"CTFshow-BJDCTF2020-RSA","slug":"CTFshow-BJDCTF2020-RSA","date":"2021-12-10T08:40:04.000Z","updated":"2021-12-10T08:53:06.676Z","comments":true,"path":"2021/12/10/CTFshow-BJDCTF2020-RSA/","link":"","permalink":"http://example.com/2021/12/10/CTFshow-BJDCTF2020-RSA/","excerpt":"最近期末，偶尔做做题消遣，这道题考察了通过求两组n的公因数从而得到p、q破解密码的攻击方法。","text":"最近期末，偶尔做做题消遣，这道题考察了通过求两组n的公因数从而得到p、q破解密码的攻击方法。 题目： 12345678910111213141516171819202122232425262728from Crypto.Util.number import getPrime,bytes_to_longflag=open(&quot;flag&quot;,&quot;rb&quot;).read()p=getPrime(1024)q=getPrime(1024)assert(e&lt;100000)n=p*qm=bytes_to_long(flag)c=pow(m,e,n)print c,nprint pow(294,e,n)p=getPrime(1024)n=p*qm=bytes_to_long(&quot;BJD&quot;*32)c=pow(m,e,n)print c,n；&#x27;&#x27;&#x27;output:12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120 13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721 12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047&#x27;&#x27;&#x27; 只需要求得n1和n2的最大公因数，就可以得到p、q的值，但是这道题没给e，可以通过爆破的方法正向加密对应密文（可能还有其他方法）求得e，脚本中注释的部分是爆破e的代码： 12345678910111213141516171819import gmpy2from Crypto.Util.number import *n1=13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037n2=12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047s=&quot;BJD&quot;*32m=bytes_to_long(s.encode())p = gmpy2.gcd(n1,n2)# for i in range(100000):# c=pow(m,i,n2)# if c==979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721:# print(i)# breake=52361q=n1//pphi = (p-1)*(q-1)d=gmpy2.invert(e,phi)c_flag=12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120flag=pow(c_flag,d,n1)print(long_to_bytes(flag)) BJD{p_is_common_divisor}","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"}]},{"title":"CTFshow-这是base？？","slug":"CTFshow-这是base？？","date":"2021-12-10T08:11:56.000Z","updated":"2022-01-13T03:07:14.672Z","comments":true,"path":"2021/12/10/CTFshow-这是base？？/","link":"","permalink":"http://example.com/2021/12/10/CTFshow-%E8%BF%99%E6%98%AFbase%EF%BC%9F%EF%BC%9F/","excerpt":"​ 打开题目文件，由两部分组成，一部分是密码算法包含的所有符号，另一部分则是密文。加密算法的符号一共64个，正好和base64的密文符号组对应，但是它的字符顺序和base64的顺序不一样，猜测应该是进行了移位，比如码值为0原本对应A的，现在对应J，所以我们只需要获取密文每个字符在当前密文符中的位置，去对应原本base64的字符就可。","text":"​ 打开题目文件，由两部分组成，一部分是密码算法包含的所有符号，另一部分则是密文。加密算法的符号一共64个，正好和base64的密文符号组对应，但是它的字符顺序和base64的顺序不一样，猜测应该是进行了移位，比如码值为0原本对应A的，现在对应J，所以我们只需要获取密文每个字符在当前密文符中的位置，去对应原本base64的字符就可。 解密脚本： 1234567891011import base64base=&#x27;JKLMNOxyUVzABCDEFGH789PQIabcdefghijklmWXYZ0123456RSTnopqrstuvw+/&#x27;base1=&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;chipertext=&#x27;FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKw&#x27;s=&#x27;&#x27;for i in chipertext: j=int(base.find(i)) s=s+base1[j]print(s)flag=base64.b64decode(s)print(flag) BJD{D0_Y0u_kNoW_Th1s_b4se_map}","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"}]},{"title":"CTFWiki-仿射密码","slug":"CTFWiki-仿射密码","date":"2021-11-27T03:22:40.000Z","updated":"2021-11-27T04:56:22.957Z","comments":true,"path":"2021/11/27/CTFWiki-仿射密码/","link":"","permalink":"http://example.com/2021/11/27/CTFWiki-%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/","excerpt":"​ 最近发现CTFWiki上有系统的一套密码学知识框架，决定跟着过一遍。 ​ 第一篇是单表代换，太基础的就不记录了，直接从仿射密码开始。首先介绍一下仿射密码的原理：","text":"​ 最近发现CTFWiki上有系统的一套密码学知识框架，决定跟着过一遍。 ​ 第一篇是单表代换，太基础的就不记录了，直接从仿射密码开始。首先介绍一下仿射密码的原理： 仿射密码的加密函数是 E(x)=(ax+b)(modm)E(x)=(ax+b)(modm)，其中 x 表示明文按照某种编码得到的数字 a 和 m互质 m是编码系统中字母的数目（比如英文字符就是26） 解密函数是 D(x)=a−1(x−b)(modm)，其中 a−1 是 a 在 Zm 群的乘法逆元。 ​ 仿射密码的密钥空间不大，存在单表替换密码的通有弊病：明文和密文一一对应，即当密文长度足够长时，我们可以使用频率分析的方法来破解。 ​ 仿射密码的破解还可以通过已知明文攻击，过程如下： ​ 已知：x1，x2以及y1=(ax1+b)(mod26)，y2=(ax2+b)(mod26) ​ 通过y1，y2两式相减，可得：y1−y2=a(x1−x2)(mod26) ​ 再通过求x1-x2模26的逆，两边相乘，就可得到a，再通过a求出b就破解了密码。 ​ 例题 1234567891011121314151617import syskey = &#x27;****CENSORED***************&#x27;flag = &#x27;TWCTF&#123;*******CENSORED********&#125;&#x27;if len(key) % 2 == 1: print(&quot;Key Length Error&quot;) sys.exit(1)n = len(key) / 2encrypted = &#x27;&#x27;for c in flag: c = ord(c) for a, b in zip(key[0:n], key[n:2*n]): c = (ord(a) * c + ord(b)) % 251 encrypted += &#x27;%02x&#x27; % cprint encrypted 1encrypted:805eed80cbbccb94c36413275780ec94a857dfec8da8ca94a8c313a8ccf9 (16进制存储) ​ 虽然题目对于 flag 中的每个字母都加密了 n 次，但仿射密码的特性是，多次加密效果类同于一次加密： c1=a1c+b1 c2=a2c1+b2=a1a2c+a2b1+b2=kc+d ​ 根据第二行的推导，我们可以得到其实 cn 也是这样的形式，可以看成 cn=xc+ycn=xc+y ，并且，我们可以知道的是，key 是始终不变化的，所以说，其实这个就是普通的仿射密码。解密代码如下： 1234567891011121314151617import gmpy2key = &#x27;****CENSORED****************&#x27;flag = &#x27;TWCTF&#123;*******CENSORED********&#125;&#x27;f = open(&#x27;encrypted&#x27;, &#x27;r&#x27;)data = f.read().strip(&#x27;\\n&#x27;)encrypted = [int(data[i:i + 2], 16) for i in range(0, len(data), 2)]plaindelta = ord(flag[1]) - ord(flag[0])cipherdalte = encrypted[1] - encrypted[0]a = gmpy2.invert(plaindelta, 251) * cipherdalte % 251b = (encrypted[0] - a * ord(flag[0])) % 251a_inv = gmpy2.invert(a, 251)result = &quot;&quot;for c in encrypted: result += chr((c - b) * a_inv % 251)print (result) ​ 结果为:TWCTF{Faster_Than_Shinkansen!}","categories":[{"name":"CTFWiki","slug":"CTFWiki","permalink":"http://example.com/categories/CTFWiki/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"CTFWiki","slug":"CTFWiki","permalink":"http://example.com/tags/CTFWiki/"},{"name":"仿射密码","slug":"仿射密码","permalink":"http://example.com/tags/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/"}]},{"title":"RSA-Wiener-Attack实现","slug":"RSA-Wiener-Attack实现","date":"2021-11-24T11:56:03.000Z","updated":"2022-01-02T07:36:24.627Z","comments":true,"path":"2021/11/24/RSA-Wiener-Attack实现/","link":"","permalink":"http://example.com/2021/11/24/RSA-Wiener-Attack%E5%AE%9E%E7%8E%B0/","excerpt":"​ 先介绍一下连分数：连分数（continued fraction）是特殊繁分数。如果a0，a1，a2，…","text":"​ 先介绍一下连分数：连分数（continued fraction）是特殊繁分数。如果a0，a1，a2，…an，…都是整数，则将分别称为无限连分数和有限连分数。可简记为a0 ，a1，a2，…，an，…和a0，a1，a2，…，an。一般一个有限连分数表示一个有理数，一个无限连分数表示一个无理数。如果a0，a1，a2，…，an，…都是实数，可将上述形式连分数分别叫无限连分数和有限连分数 。近代数学的计算需要，还可将连分数中的a0，a1 ，a2，…，an，…取成以x为变元的多项式。在近代计算数学中它常与某些微分方程式差分方程有关，与某些递推关系有关的函数构造的应用相联系。 ​ 研究连分数的动机源于想要有实数在“数学上纯粹”的表示。这里的a0 可以是任意整数，其它ai 都是 {0, 1, 2, …, 9} 的一个元素。在这种表示中，例如数 π 被表示为整数序列 {3, 1, 4, 1, 5, 9, 2, …}。这种小数表示有些问题。例如，在这种情况下使用常数 10 是因为我们使用了 10进制系统。我们还可以使用 8进制或 2 进制系统。另一个问题是很多有理数在这个系统内缺乏有限表示。例如，数 1/3 被表示为无限序列 {0, 3, 3, 3, 3, ….}。连分数表示法是避免了实数表示的这两个问题。让我们考虑如何描述一个数如 415/93，约为 4.4624。近似为 4，而实际上比 4 多一点，约为 4 + 1/2。但是在分母中的 2 是不准确的；更准确的分母是比 2 多一点，约为 2 + 1/6，所以 415/93 近似为 4 + 1/(2 + 1/6)。但是在分母中的 6 是不准确的；更准确分母是比 6 多一点，实际是 6+1/7。所以 415/93 实际上是 4+1/(2+1/(6+1/7))。这样才准确 。去掉表达式 4 + 1/(2 + 1/(6 + 1/7)) 中的冗余部分可得到简略记号 [4; 2, 6, 7]。 ​ 维纳攻击的原理已经在上篇讲的很详细，这里直接给出攻击实现的代码： 1234567891011121314151617181920212223242526272829def continuedFra(x, y): #不断生成连分数的项 cF = [] while y: cF += [x // y] x, y = y, x % y return cFdef Simplify(ctnf): #化简 numerator = 0 denominator = 1 for x in ctnf[::-1]: #注意这里是倒叙遍历 numerator, denominator = denominator, x * denominator + numerator return (numerator, denominator) #把连分数分成分子和算出来的分母def getit(c): cf=[] for i in range(1,len(c)): cf.append(Simplify(c[:i])) #各个阶段的连分数的分子和分母 return cf #得到一串连分数def wienerAttack(e, n): cf=continuedFra(e,n) for (k,d) in getit(cf):#遍历得到的连分数，令分子分母分别是k，d if d == 0: continue if type((e*d-1)/k)== int: #必须满足phi(n)为整数 return d#注意这里的d还不一定是私钥，可以利用d和k的值以及phi(n)与p，q的关系列出一元二次方程，放入sage求解，若可求出p，q则无误 print(&#x27;not find!&#x27;) ​ 当通过维纳攻击找到d，p，q的值时，整个密码也就被破解了。","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"RSA","slug":"比赛/RSA","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/"},{"name":"维纳攻击","slug":"比赛/RSA/维纳攻击","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"维纳攻击","slug":"维纳攻击","permalink":"http://example.com/tags/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/"}]},{"title":"RSA_Wiener_Attack原理","slug":"RSA-Wiener-Attack原理","date":"2021-11-23T12:44:28.000Z","updated":"2022-03-17T14:40:41.310Z","comments":true,"path":"2021/11/23/RSA-Wiener-Attack原理/","link":"","permalink":"http://example.com/2021/11/23/RSA-Wiener-Attack%E5%8E%9F%E7%90%86/","excerpt":"先描述一下RSA密码体制： RSA密码体制：","text":"先描述一下RSA密码体制： RSA密码体制： 考虑RSA密码体制：n = pq，其中p 和q 是素数。ϕ ( n ) = ( p − 1 ) ( q − 1 ) 。我们知道RSA的加解密主要进行模幂运算，如果利用快速平方乘方法的话，选择一个较小的解密指数会大幅度降低计算时间，提高解密效率。但是这里指出：应该避免解密指数过小。 这里介绍由M.Wiener提出的一种攻击，可以计算出解密指数a。前提条件是： 并且满足：如果n 的二进制表示有L比特，那么当e的二进制表示位数小于L/4-1，p和q 相距不太远时，攻击才算有效。 由连分数的理论可知，此时t/a是b/n的一个收敛子。 因为n和b都是公开的，计算收敛子是容易的。我们只要计算出b/n的所有收敛子，看哪个收敛子可以分解n。（如果t/a是收敛子，我们就有了a和t的值，依据ϕ(n)=(ab−1)/t 就可以计算出ϕ ( n ) ，进而可以解一元二次方程求出p，以此为判断依据确定哪个收敛子才是真正的t和a。） 验证结束之后，我们就可以得到a的值，不仅破解了密码，大整数n 也被分解了。","categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"RSA","slug":"比赛/RSA","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/"},{"name":"维纳攻击","slug":"比赛/RSA/维纳攻击","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"维纳攻击","slug":"维纳攻击","permalink":"http://example.com/tags/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/"}]},{"title":"Python_basic_class1","slug":"python-class1","date":"2021-11-23T12:04:31.000Z","updated":"2021-11-23T12:19:50.979Z","comments":true,"path":"2021/11/23/python-class1/","link":"","permalink":"http://example.com/2021/11/23/python-class1/","excerpt":"Python类的构造和默认标准方法的使用，实现了一个‘分数类’，对于理解面向对象编程比较实用。","text":"Python类的构造和默认标准方法的使用，实现了一个‘分数类’，对于理解面向对象编程比较实用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105# 欧几里得算法求最大公约数def gcd(m, n): while m % n != 0: oldm = m oldn = n m = oldn n = oldm % oldn return nclass Fraction: # 构造方法，self是一个总指向对象本身的特殊参数，它必须是第一个形式参数，这里先约分再返回分数 def __init__(self, top, bottom): if((type(top) != int) or (type(bottom) != int)): #判断输入的数字是否为整数，不是则异常 raise RuntimeError(&quot;You must input integer!&quot;) else: common = gcd(top, bottom) self.num = top // common self.den = bottom // common # _str_方法是类中默认用来实现将对象转为字符串的方法，这里重写它 def __str__(self): return str(str(self.num)+&quot;/&quot;+str(self.den)) # _add_方法是类中默认用来实现相加的方法，这里将它重写，使得可以进行两分数的加法，这里不需要再化简结果（构造函数已经做了） def __add__(self, other): newnum = self.num * other.den + \\ self.den * other.num newden = self.den * other.den return Fraction(newnum,newden) #_sub_方法用来实现减法 def __sub__(self, other): newnum = self.num * other.den - \\ self.den * other.num newden = self.den * other.den return Fraction(newnum,newden) #_mul_方法用来实现乘法 def __mul__(self, other): newnum = self.num * other.num newden = self.den * other.den return Fraction(newnum,newden) #_truediv_方法实现除法 def __truediv__(self, other): newnum = self.num * other.den newden = self.den * other.num return Fraction(newnum,newden) # 利用交叉相乘来判断两个对象的值是否相等（深相等） def __eq__(self, other): firstnum = self.num * other.den secondnum = other.num * self.den return firstnum == secondnum #_gt_方法判断self对象是否大于other对象 def __gt__(self, other): selfnum = self.num * other.den othernum = other.num * self.den return selfnum &gt; othernum #_ge_方法判断self对象是否大于等于other对象 def __ge__(self, other): selfnum = self.num * other.den othernum = other.num * self.den return selfnum &gt;= othernum #_lt_方法判断self对象是否小于other对象 def __lt__(self, other): selfnum = self.num * other.den othernum = other.num * self.den return selfnum &lt; othernum #_ne_方法判断是否不相等（!=），当只定义_eq_时，在实际调用!=时会将_eq_取反，大小于也是同样道理（可以只定义一个） def __ne__(self, other): if (self.num != other.num) or (self.den !=other.den): return True #getNum和getDen分别返回分数的分子和分母 def getNum(self): return self.num def getDen(self): return self.den #_radd_方法 +号左侧对象没有_add_方法时，会在右侧对象寻找并调用_radd_，此时的self是 + 右端对象 def __radd__(self, other): newnum = self.num * other.den + \\ self.den * other.num newden = self.den * other.den return Fraction(newnum, newden)if __name__ == &#x27;__main__&#x27;: f1 = Fraction(6,-8) f2 = Fraction(7,4) print(f1+f2) print(f1-f2) print(f2.getDen()) print(f2.getNum()) print(f1&gt;=f2) print(f1==f2)","categories":[{"name":"python数据结构与算法","slug":"python数据结构与算法","permalink":"http://example.com/categories/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://example.com/tags/python%E5%9F%BA%E7%A1%80/"},{"name":"面向对象","slug":"面向对象","permalink":"http://example.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"CTFshow—Crypto 13","slug":"13","date":"2021-11-22T01:49:44.000Z","updated":"2021-11-22T05:10:13.829Z","comments":true,"path":"2021/11/22/13/","link":"","permalink":"http://example.com/2021/11/22/13/","excerpt":"打开题目所给文件，仅有一个base.txt，并且很长，直接跳到末尾发现等号，于是猜测应该是base32或base64。","text":"打开题目所给文件，仅有一个base.txt，并且很长，直接跳到末尾发现等号，于是猜测应该是base32或base64。 由于base家族编码以后密文比明文更长，所以猜测base.txt是加密很多次过后的结果，由于不确定过程中究竟用了几种加密，写脚本的时候可以分情况遍历。脚本如下： 12345678910111213141516171819202122232425262728293031323334import base64s=&#x27;&#x27;with open(&#x27;base.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f: s=&#x27;&#x27;.join(f.readlines()).encode(&#x27;utf-8&#x27;)src=s while True: try: src=s s=base64.b16decode(s) str(s,&#x27;utf-8&#x27;) continue except: pass try: src=s s=base64.b32decode(s) str(s,&#x27;utf-8&#x27;) continue except: pass try: src=s s=base64.b64decode(s) str(s,&#x27;utf-8&#x27;) continue except: pass breakwith open(&#x27;result.txt&#x27;,&#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as file: file.write(str(src,&#x27;utf-8&#x27;))print(&quot;Decryption complete!&quot;) 结果：","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-11-17T11:31:29.930Z","updated":"2021-11-22T05:07:48.063Z","comments":true,"path":"2021/11/17/hello-world/","link":"","permalink":"http://example.com/2021/11/17/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}],"categories":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"对称密码","slug":"比赛/对称密码","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/"},{"name":"中间相遇攻击","slug":"比赛/对称密码/中间相遇攻击","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/%E4%B8%AD%E9%97%B4%E7%9B%B8%E9%81%87%E6%94%BB%E5%87%BB/"},{"name":"RSA","slug":"比赛/RSA","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/"},{"name":"Copper","slug":"比赛/RSA/Copper","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/Copper/"},{"name":"pollard's p-1","slug":"比赛/RSA/pollard-s-p-1","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/pollard-s-p-1/"},{"name":"同态加密","slug":"比赛/同态加密","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"},{"name":"Paillier","slug":"比赛/同态加密/Paillier","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/Paillier/"},{"name":"PWNHUB","slug":"PWNHUB","permalink":"http://example.com/categories/PWNHUB/"},{"name":"公开赛","slug":"PWNHUB/公开赛","permalink":"http://example.com/categories/PWNHUB/%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"name":"LFSR","slug":"比赛/LFSR","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/LFSR/"},{"name":"矩阵方程求解法","slug":"比赛/LFSR/矩阵方程求解法","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/LFSR/%E7%9F%A9%E9%98%B5%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3%E6%B3%95/"},{"name":"小指数加密","slug":"比赛/RSA/小指数加密","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/%E5%B0%8F%E6%8C%87%E6%95%B0%E5%8A%A0%E5%AF%86/"},{"name":"Secret Sharing","slug":"比赛/Secret-Sharing","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/Secret-Sharing/"},{"name":"Shamir&Asmuth-Bloom","slug":"比赛/Secret-Sharing/Shamir-Asmuth-Bloom","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/Secret-Sharing/Shamir-Asmuth-Bloom/"},{"name":"buu","slug":"buu","permalink":"http://example.com/categories/buu/"},{"name":"刷题总结","slug":"buu/刷题总结","permalink":"http://example.com/categories/buu/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"name":"赛事","slug":"赛事","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/"},{"name":"HSC-1th 2022","slug":"赛事/HSC-1th-2022","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/HSC-1th-2022/"},{"name":"数论或其它","slug":"比赛/RSA/数论或其它","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/%E6%95%B0%E8%AE%BA%E6%88%96%E5%85%B6%E5%AE%83/"},{"name":"VNCTF2022","slug":"赛事/VNCTF2022","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/VNCTF2022/"},{"name":"Docker学习","slug":"Docker学习","permalink":"http://example.com/categories/Docker%E5%AD%A6%E4%B9%A0/"},{"name":"Blockchain","slug":"Blockchain","permalink":"http://example.com/categories/Blockchain/"},{"name":"基础知识","slug":"Blockchain/基础知识","permalink":"http://example.com/categories/Blockchain/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"HGAME2022","slug":"赛事/HGAME2022","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/HGAME2022/"},{"name":"CTFshow-1024杯","slug":"赛事/CTFshow-1024杯","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/CTFshow-1024%E6%9D%AF/"},{"name":"基本原理","slug":"比赛/LFSR/基本原理","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/LFSR/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"},{"name":"CTFshow-摆烂杯","slug":"赛事/CTFshow-摆烂杯","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/CTFshow-%E6%91%86%E7%83%82%E6%9D%AF/"},{"name":"CTFshow-月饼杯","slug":"赛事/CTFshow-月饼杯","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/CTFshow-%E6%9C%88%E9%A5%BC%E6%9D%AF/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"},{"name":"其它加密算法","slug":"其它加密算法","permalink":"http://example.com/categories/%E5%85%B6%E5%AE%83%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"},{"name":"长安战疫","slug":"赛事/长安战疫","permalink":"http://example.com/categories/%E8%B5%9B%E4%BA%8B/%E9%95%BF%E5%AE%89%E6%88%98%E7%96%AB/"},{"name":"python数据结构与算法","slug":"python数据结构与算法","permalink":"http://example.com/categories/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"伪随机数生成器","slug":"比赛/伪随机数生成器","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"LCG","slug":"比赛/伪随机数生成器/LCG","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8/LCG/"},{"name":"CTFWiki","slug":"CTFWiki","permalink":"http://example.com/categories/CTFWiki/"},{"name":"维纳攻击","slug":"比赛/RSA/维纳攻击","permalink":"http://example.com/categories/%E6%AF%94%E8%B5%9B/RSA/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://example.com/tags/crypto/"},{"name":"AES","slug":"AES","permalink":"http://example.com/tags/AES/"},{"name":"中间相遇攻击","slug":"中间相遇攻击","permalink":"http://example.com/tags/%E4%B8%AD%E9%97%B4%E7%9B%B8%E9%81%87%E6%94%BB%E5%87%BB/"},{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"Copper","slug":"Copper","permalink":"http://example.com/tags/Copper/"},{"name":"光滑数攻击","slug":"光滑数攻击","permalink":"http://example.com/tags/%E5%85%89%E6%BB%91%E6%95%B0%E6%94%BB%E5%87%BB/"},{"name":"同态加密","slug":"同态加密","permalink":"http://example.com/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"},{"name":"pwnhub","slug":"pwnhub","permalink":"http://example.com/tags/pwnhub/"},{"name":"LFSR","slug":"LFSR","permalink":"http://example.com/tags/LFSR/"},{"name":"小指数加密","slug":"小指数加密","permalink":"http://example.com/tags/%E5%B0%8F%E6%8C%87%E6%95%B0%E5%8A%A0%E5%AF%86/"},{"name":"中国剩余定理","slug":"中国剩余定理","permalink":"http://example.com/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"name":"Secret Sharing","slug":"Secret-Sharing","permalink":"http://example.com/tags/Secret-Sharing/"},{"name":"buu","slug":"buu","permalink":"http://example.com/tags/buu/"},{"name":"赛事","slug":"赛事","permalink":"http://example.com/tags/%E8%B5%9B%E4%BA%8B/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"},{"name":"misc","slug":"misc","permalink":"http://example.com/tags/misc/"},{"name":"re","slug":"re","permalink":"http://example.com/tags/re/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"Blockchain","slug":"Blockchain","permalink":"http://example.com/tags/Blockchain/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"},{"name":"python数据结构","slug":"python数据结构","permalink":"http://example.com/tags/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"队列","slug":"队列","permalink":"http://example.com/tags/%E9%98%9F%E5%88%97/"},{"name":"PRNG","slug":"PRNG","permalink":"http://example.com/tags/PRNG/"},{"name":"LCG","slug":"LCG","permalink":"http://example.com/tags/LCG/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"CTFWiki","slug":"CTFWiki","permalink":"http://example.com/tags/CTFWiki/"},{"name":"仿射密码","slug":"仿射密码","permalink":"http://example.com/tags/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/"},{"name":"维纳攻击","slug":"维纳攻击","permalink":"http://example.com/tags/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/"},{"name":"python基础","slug":"python基础","permalink":"http://example.com/tags/python%E5%9F%BA%E7%A1%80/"},{"name":"面向对象","slug":"面向对象","permalink":"http://example.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}